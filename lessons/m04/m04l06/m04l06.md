# Занятие 6: Основные операции с DataFrame. Фильтрация и сортировка. Работа с датами и пустыми значениями.

## 1. Фильтрация данных в DataFrame

Фильтрация данных в DataFrame — это важный этап анализа данных, позволяющий отобрать только те строки, которые соответствуют заданным условиям. В Pandas это делается с помощью логических выражений, что делает процесс очень гибким и мощным.

### Фильтрация по одному условию

Фильтрация по одному условию — это самый простой способ выделить нужные данные. Мы можем использовать логические операторы (например, `==`, `>`, `<`, `!=` и т.д.) для создания маски, которая вернет только те строки, которые удовлетворяют нашему условию.

**Пример:**
```python
import pandas as pd

# Создаем DataFrame
data = {'Name': ['Alice', 'Bob', 'Charlie', 'David'],
        'Age': [25, 30, 35, 40]}
df = pd.DataFrame(data)

# Фильтруем по условию: выбираем только тех, кто старше 30 лет
filtered_df = df[df['Age'] > 30]
```
В этом примере мы создаем маску `df['Age'] > 30`, которая возвращает `True` для строк, где возраст больше 30, и `False` в противном случае. В результате получаем DataFrame, состоящий только из строк с подходящими значениями.

### Фильтрация по нескольким условиям

Когда необходимо фильтровать данные по нескольким условиям, мы можем использовать логические операторы `&` (AND) и `|` (OR). При этом важно заключать каждое условие в скобки, чтобы избежать путаницы в приоритете операций.

**Пример:**
```python
# Фильтруем по двум условиям: выбираем людей старше 30 лет и младше 40
filtered_df = df[(df['Age'] > 30) & (df['Age'] < 40)]
```
Здесь мы используем оператор `&` для объединения двух условий. Полученный DataFrame будет включать только строки, удовлетворяющие обоим критериям.

### Фильтрация с использованием методов .isin() и .between()

Методы `.isin()` и `.between()` позволяют делать фильтрацию более удобной и читаемой, особенно когда условия сложные или когда нужно проверить наличие значений в списке.

- **Метод `.isin()`** используется для фильтрации строк, где значения одного столбца находятся в заданном списке.

**Пример:**
```python
# Фильтруем по списку имен
filtered_df = df[df['Name'].isin(['Alice', 'Bob'])]
```
Этот код возвращает DataFrame, в котором только строки с именами "Alice" и "Bob".

- **Метод `.between()`** позволяет фильтровать данные по диапазону значений.

**Пример:**
```python
# Фильтруем по диапазону возрастов
filtered_df = df[df['Age'].between(30, 40)]
```
Здесь мы получаем строки, где возраст находится в диапазоне от 30 до 40, включая границы.

### Работа с пропусками: фильтрация с .isnull() и .notnull()

Работа с пропусками — это важный аспект обработки данных. Методы `.isnull()` и `.notnull()` позволяют выявлять и фильтровать строки с отсутствующими значениями.

- **Метод `.isnull()`** возвращает булеву маску, показывающую, где находятся пропущенные значения.

**Пример:**
```python
# Создаем DataFrame с пропущенными значениями
data_with_nan = {'Name': ['Alice', 'Bob', None, 'David'],
                  'Age': [25, None, 35, 40]}
df_nan = pd.DataFrame(data_with_nan)

# Фильтруем строки с пропущенными именами
filtered_df = df_nan[df_nan['Name'].isnull()]
```
В этом примере мы получаем строки, где имя отсутствует (пропущено).

- **Метод `.notnull()`** работает аналогично, но возвращает строки, где данные присутствуют.

**Пример:**
```python
# Фильтруем строки без пропущенных имен
filtered_df = df_nan[df_nan['Name'].notnull()]
```
В этом случае мы получаем DataFrame, который содержит только те строки, где имя указано.

## 2. Сортировка данных в DataFrame

Сортировка данных в DataFrame — это ключевая операция, которая позволяет организовать данные в определенном порядке. Это упрощает анализ, помогает выявить закономерности и делает данные более наглядными.

### Зачем нужна сортировка данных?

Сортировка данных важна по нескольким причинам:

1. **Упрощение анализа**: Сортированные данные легче анализировать. Например, можно быстро увидеть, какие значения минимальны или максимальны.
2. **Подготовка к визуализации**: Многие графики и диаграммы требуют упорядоченных данных. Сортировка помогает правильно подготовить данные перед визуализацией.
3. **Выявление закономерностей**: Сортировка по определенным критериям может выявить интересные тенденции и аномалии в данных.
4. **Логическая организация**: Иногда данные требуется представить в определенном порядке (например, по алфавиту или по времени), чтобы они были более понятными для пользователя.

### Основной метод .sort_values()

Метод `.sort_values()` является основным инструментом для сортировки данных в DataFrame. Он позволяет сортировать данные по одному или нескольким столбцам.

**Пример:**
```python
import pandas as pd

# Создаем DataFrame
data = {'Name': ['Alice', 'Bob', 'Charlie', 'David'],
        'Age': [25, 30, 35, 40]}
df = pd.DataFrame(data)

# Сортируем по возрасту
sorted_df = df.sort_values(by='Age')
```
В этом примере мы сортируем DataFrame по столбцу 'Age'. Результатом будет новый DataFrame, отсортированный по возрастанию возраста.

### Параметры сортировки: ascending, inplace

Метод `.sort_values()` имеет несколько важных параметров, которые управляют поведением сортировки.

- **ascending**: Этот параметр указывает, в каком порядке следует сортировать данные — по возрастанию (True) или по убыванию (False). По умолчанию стоит True.

**Пример:**
```python
# Сортируем по возрасту в порядке убывания
sorted_df_desc = df.sort_values(by='Age', ascending=False)
```
В этом примере мы получаем DataFrame, отсортированный по возрасту от большего к меньшему.

- **inplace**: Параметр `inplace` определяет, следует ли изменять исходный DataFrame или возвращать новый. Если установить `inplace=True`, изменения будут применены к исходному DataFrame, и он будет перезаписан. Если `inplace=False`, метод вернет новый DataFrame, а исходный останется неизменным.

**Пример:**
```python
# Сортируем DataFrame на месте
df.sort_values(by='Age', inplace=True)
```
Здесь исходный DataFrame `df` будет изменен, и данные в нем будут отсортированы по возрасту.

### Сортировка по индексу: .sort_index()

Иногда может возникнуть необходимость сортировать данные по индексу, а не по значению столбцов. Для этого используется метод `.sort_index()`. Он сортирует DataFrame по его индексам.

**Пример:**
```python
# Создаем DataFrame с неупорядоченными индексами
data = {'Name': ['Alice', 'Bob', 'Charlie', 'David'],
        'Age': [25, 30, 35, 40]}
df = pd.DataFrame(data, index=[3, 1, 4, 2])

# Сортируем по индексу
sorted_index_df = df.sort_index()
```
В этом примере мы создаем DataFrame с произвольными индексами. Затем применяем метод `.sort_index()`, который вернет DataFrame, отсортированный по индексам в порядке возрастания.

### Применение фильтрации перед сортировкой

Фильтрация перед сортировкой позволяет сосредоточиться на конкретной подмножестве данных, что часто необходимо для более глубокого анализа. Когда вы сначала применяете фильтрацию, вы можете отсортировать только те строки, которые действительно вас интересуют, исключая ненужные значения и шум.

**Пример:**
```python
import pandas as pd

# Создаем DataFrame
data = {
    'Name': ['Alice', 'Bob', 'Charlie', 'David', 'Eva'],
    'Age': [25, 30, 35, 30, 22],
    'Score': [88, 92, 95, 85, 90]
}
df = pd.DataFrame(data)

# Фильтруем людей старше 30 лет и сортируем по оценкам
filtered_sorted_df = df[df['Age'] > 30].sort_values(by='Score', ascending=False)
```
В этом примере сначала мы фильтруем DataFrame, чтобы оставить только людей старше 30 лет. Затем сортируем полученный набор данных по столбцу 'Score' в порядке убывания. Это позволяет нам сосредоточиться на наилучших результатах среди старших участников.

## 3. Преобразование строк в даты

Преобразование строк в даты — важный шаг при обработке данных, особенно если вы работаете с временными рядами или данными, связанными с датами. Pandas предлагает удобные инструменты для работы с датами, что значительно упрощает этот процесс.

### Форматы дат и времени в Pandas

В Pandas поддерживается множество форматов дат и времени, что позволяет работать с данными, представленными в различных стилях. Основные форматы включают:

- **Год-месяц-день**: `YYYY-MM-DD` (например, `2023-11-04`)
- **День-месяц-год**: `DD/MM/YYYY` (например, `04/11/2023`)
- **Месяц-день-год**: `MM-DD-YYYY` (например, `11-04-2023`)
- **Точные временные метки**: `YYYY-MM-DD HH:MM:SS` (например, `2023-11-04 12:30:00`)

Важно помнить, что правильное преобразование строк в даты зависит от их исходного формата. Неправильное определение формата может привести к ошибкам или неверным значениям.

### Использование pd.to_datetime()

Метод `pd.to_datetime()` — основной инструмент для преобразования строк в объекты типа datetime в Pandas. Он автоматически распознает большинство стандартных форматов, но иногда может потребоваться явное указание формата.

**Пример:**
```python
import pandas as pd

# Создаем DataFrame со строковыми датами
data = {'date_string': ['2023-11-04', '2023-11-05', '2023-11-06']}
df = pd.DataFrame(data)

# Преобразуем строку в дату
df['date'] = pd.to_datetime(df['date_string'])
```
В этом примере мы создали новый столбец 'date', который содержит преобразованные даты. Метод `pd.to_datetime()` автоматически распознает формат `YYYY-MM-DD`.

### Указание формата дат через параметр format

Если строки имеют нестандартный формат или если вы хотите ускорить процесс преобразования, можно использовать параметр `format`. Это позволяет явно указать, как должны быть интерпретированы строки.

**Пример:**
```python
# Создаем DataFrame с нестандартным форматом дат
data = {'date_string': ['04/11/2023', '05/11/2023', '06/11/2023']}
df = pd.DataFrame(data)

# Преобразуем с указанием формата
df['date'] = pd.to_datetime(df['date_string'], format='%d/%m/%Y')
```
В этом примере мы явно указали формат `%d/%m/%Y`, что позволяет Pandas корректно распознать день, месяц и год. Это особенно полезно при работе с международными датами, где формат может варьироваться.

### Преобразование с разными форматами

```python
data = {'date_string': ['2023-11-04', '11-05-2023', '2023.11.06']}
df = pd.DataFrame(data)

# Пробуем преобразовать с автоматическим определением
df['date'] = pd.to_datetime(df['date_string'], errors='coerce')
```
Здесь мы используем `errors='coerce'`, чтобы заменить некорректные даты на NaT (Not a Time).

## 4. Извлечение компонентов даты

Извлечение компонентов даты — это полезная операция, которая позволяет анализировать данные на основе отдельных элементов даты, таких как год, месяц и день. В Pandas это делается с помощью атрибутов объекта datetime, что делает процесс интуитивным и простым.

### Доступ к атрибутам даты (год, месяц, день)

Когда вы работаете с данными типа datetime, Pandas предоставляет доступ к различным компонентам даты через специальные атрибуты. Это позволяет легко извлекать необходимую информацию и использовать её в анализе.

- **Год**: доступен через атрибут `.dt.year`
- **Месяц**: доступен через атрибут `.dt.month`
- **День**: доступен через атрибут `.dt.day`

**Пример:**
```python
import pandas as pd

# Создаем DataFrame с датами
data = {'date': ['2023-11-04', '2023-11-05', '2023-11-06']}
df = pd.DataFrame(data)

# Преобразуем строки в даты
df['date'] = pd.to_datetime(df['date'])

# Извлекаем компоненты даты
df['year'] = df['date'].dt.year
df['month'] = df['date'].dt.month
df['day'] = df['date'].dt.day
```
В этом примере мы сначала преобразуем строки в тип datetime, а затем извлекаем год, месяц и день, создавая новые столбцы `year`, `month` и `day`. Это позволяет анализировать данные по отдельным временным компонентам.

### Использование .dt для извлечения данных

Атрибут `.dt` — это специальный доступ к методам и свойствам объектов datetime в Pandas. Он позволяет извлекать различные компоненты даты не только через простые атрибуты, но и через методы, что дает больше возможностей для анализа.

Например, с помощью `.dt` можно получить информацию о днях недели, неделях в году и даже о кварталах.

**Пример:**
```python
# Извлекаем день недели (0 - понедельник, 6 - воскресенье)
df['day_of_week'] = df['date'].dt.dayofweek

# Извлекаем номер квартала
df['quarter'] = df['date'].dt.quarter
```
Здесь мы добавляем столбец `day_of_week`, который показывает номер дня недели, и столбец `quarter`, который указывает номер квартала. Это может быть полезно для анализа сезонных тенденций или распределения данных по дням недели.

### Примеры создания новых столбцов на основе компонентов даты

Извлечение компонентов даты также позволяет создавать новые столбцы, которые могут быть использованы для дальнейшего анализа или визуализации.

**Пример:**
```python
# Создаем столбец, который содержит дату в формате 'день.месяц.год'
df['formatted_date'] = df['date'].dt.strftime('%d.%m.%Y')

# Создаем новый столбец, который показывает, является ли дата выходным
df['is_weekend'] = df['day_of_week'].isin([5, 6])  # 5 - суббота, 6 - воскресенье
```
В этом примере мы используем метод `.strftime()` для форматирования даты в удобочитаемый вид. Также создаем столбец `is_weekend`, который указывает, является ли дата выходным днем. Это может быть полезно для анализа активности в зависимости от дня недели.

## 5. Операции с датами

Операции с датами в Pandas являются важной частью анализа временных рядов и работы с временными данными. Понимание того, как выполнять сложение и вычитание дат, а также как использовать временные интервалы, помогает более эффективно манипулировать данными.

### Сложение и вычитание дат

В Pandas можно легко выполнять операции сложения и вычитания с объектами типа datetime. Это позволяет, например, находить новые даты, добавляя или вычитая определённое количество дней, месяцев или лет.

**Пример:**
```python
import pandas as pd

# Создаем DataFrame с датами
data = {'start_date': ['2023-11-01', '2023-11-02']}
df = pd.DataFrame(data)

# Преобразуем строки в даты
df['start_date'] = pd.to_datetime(df['start_date'])

# Сложение: добавляем 10 дней
df['new_date'] = df['start_date'] + pd.Timedelta(days=10)

# Вычитание: вычитаем 5 дней
df['previous_date'] = df['start_date'] - pd.Timedelta(days=5)
```
В этом примере мы создали новый столбец `new_date`, добавляя 10 дней к исходной дате, и столбец `previous_date`, вычитая 5 дней. Использование `pd.Timedelta` позволяет задавать временные интервалы в днях, часах, минутах и других единицах.

### Использование timedelta для работы с разницей дат

Объект `timedelta` в Pandas позволяет вычислять разницу между двумя датами, а также добавлять или вычитать временные интервалы. Это очень полезно при анализе временных рядов, например, для нахождения продолжительности событий или промежутков времени.

**Пример:**
```python
# Создаем DataFrame с датами окончания задач
data = {'start_date': ['2023-11-01', '2023-11-02'], 
        'end_date': ['2023-11-10', '2023-11-07']}
df = pd.DataFrame(data)

# Преобразуем строки в даты
df['start_date'] = pd.to_datetime(df['start_date'])
df['end_date'] = pd.to_datetime(df['end_date'])

# Вычисляем разницу между датами
df['duration'] = df['end_date'] - df['start_date']
```
Здесь мы создаём новый столбец `duration`, который содержит разницу между датами начала и окончания. Результатом будет объект типа `timedelta`, который показывает, сколько дней прошло между двумя датами. Это особенно полезно для оценки продолжительности проектов или событий.

### Фильтрация данных по датам

Фильтрация данных по датам позволяет выделять записи, соответствующие определённым временным интервалам. Это полезно для анализа данных за заданный период, например, для изучения продаж по месяцам или событий в течение года.

**Пример:**
```python
# Создаем DataFrame с датами и значениями
data = {
    'date': ['2023-11-01', '2023-11-02', '2023-11-10', '2023-12-01'],
    'value': [100, 150, 200, 250]
}
df = pd.DataFrame(data)

# Преобразуем строки в даты
df['date'] = pd.to_datetime(df['date'])

# Фильтруем данные по дате
start_date = '2023-11-01'
end_date = '2023-11-30'
filtered_df = df[(df['date'] >= start_date) & (df['date'] <= end_date)]
```
В этом примере мы фильтруем DataFrame, чтобы получить только те строки, где дата находится в диапазоне от 1 ноября до 30 ноября 2023 года. Это позволяет сосредоточиться на конкретном временном интервале для дальнейшего анализа или визуализации.

## 6. Работа с пустыми значениями

Пустые значения могут возникать по различным причинам, например, из-за отсутствия данных или ошибок при сборе информации. Эффективная работа с ними важна для анализа и обработки данных.

### Определение пустых значений в DataFrame

**Пустые значения** в pandas обозначаются как `NaN` (Not a Number). Они представляют собой отсутствие данных в определенных ячейках DataFrame. Понимание того, как идентифицировать эти значения, является первым шагом в их обработке.

### Методы проверки на пустые значения

**`.isnull()`**

Метод `.isnull()` возвращает новый DataFrame, в котором значения `NaN` представлены как `True`, а все остальные значения — как `False`. Это позволяет быстро увидеть, где находятся пустые значения.

**Пример использования:**
```python
import pandas as pd

data = {'A': [1, 2, None], 'B': [4, None, 6]}
df = pd.DataFrame(data)
print(df.isnull())
```

Этот код выдаст:
```
       A      B
0  False  False
1  False   True
2   True  False
```

**`.notnull()`**

Метод `.notnull()` работает аналогично `.isnull()`, но возвращает `True` для непустых значений и `False` для пустых.

**Пример использования:**
```python
print(df.notnull())
```

Результат будет:
```
       A      B
0   True   True
1   True  False
2  False   True
```

### Удаление пустых значений

**`.dropna()`**

Метод `.dropna()` позволяет удалить строки или столбцы, содержащие пустые значения. По умолчанию он удаляет строки, но вы можете изменить поведение, указав параметр `axis`.

**Пример удаления строк:**
```python
df_cleaned = df.dropna()
print(df_cleaned)
```

Если в DataFrame есть строки с пустыми значениями, они будут исключены.

**Пример удаления столбцов:**
```python
df_cleaned_columns = df.dropna(axis=1)
print(df_cleaned_columns)
```

В этом случае будут удалены столбцы, которые содержат хотя бы одно пустое значение.

### Заполнение пустых значений

Заполнение пустых значений — это важный этап в подготовке данных, который помогает сохранить целостность набора данных и избежать искажений в анализе. Пустые значения могут представлять собой пробелы в информации, и их обработка позволяет улучшить качество и полноту данных. 

#### Метод .fillna()

Метод `.fillna()` в библиотеке pandas предоставляет различные способы заполнения пустых значений в DataFrame. Он позволяет указать конкретное значение, на которое будут заменены пустые ячейки, или применить более сложные методы заполнения.

- **value**: Значение, на которое будут заменены пустые значения.
- **method**: Метод заполнения (`'ffill'`, `'bfill'`).
- **limit**: Ограничивает количество замен, которые могут быть выполнены.
- **inplace**: Если `True`, изменения будут внесены непосредственно в исходный DataFrame.

#### Заполнение фиксированным значением

Допустим, у нас есть следующий DataFrame:

```python
import pandas as pd

data = {'A': [1, 2, None], 'B': [None, 4, 6]}
df = pd.DataFrame(data)
print("Исходный DataFrame:")
print(df)
```

**Результат:**
```
     A    B
0  1.0  NaN
1  2.0  4.0
2  NaN  6.0
```

Вы можете заполнить все пустые значения фиксированным значением, например, 0:

```python
df_filled = df.fillna(0)
print("\nDataFrame после заполнения пустых значений нулями:")
print(df_filled)
```

**Результат:**
```
     A    B
0  1.0  0.0
1  2.0  4.0
2  0.0  6.0
```

#### Заполнение средними значениями

Часто полезно заполнять пустые значения средними значениями по соответствующим столбцам. Это может помочь сохранить распределение данных:

```python
mean_A = df['A'].mean()
df['A'] = df['A'].fillna(mean_A)
print("\nDataFrame после заполнения пустых значений средним значением столбца 'A':")
print(df)
```

**Результат:**
```
     A    B
0  1.0  NaN
1  2.0  4.0
2  1.5  6.0
```

#### Заполнение методом `ffill` (forward fill)

Этот метод заполняет пустые значения последним известным значением, идущим перед ним:

```python
df_filled_ffill = df.fillna(method='ffill')
print(df_filled_ffill)
```

**Результат:**
```
     A    B
0  1.0  NaN
1  2.0  4.0
2  2.0  6.0
```

#### Заполнение методом `bfill` (backward fill)

Этот метод заполняет пустые значения следующим известным значением, идущим после него:

```python
df_filled_bfill = df.fillna(method='bfill')
print(df_filled_bfill)
```

**Результат:**
```
     A    B
0  1.0  4.0
1  2.0  4.0
2  2.0  6.0
```


