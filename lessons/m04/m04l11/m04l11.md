# Занятие 11: Введение в OpenCV

## 1. Введение в OpenCV

### Что такое OpenCV и зачем он нужен?

**OpenCV** (Open Source Computer Vision Library) — это библиотека с открытым исходным кодом, предназначенная для решения задач компьютерного зрения и обработки изображений. Библиотека предоставляет мощные инструменты для работы с изображениями и видео, а также для реализации различных алгоритмов машинного обучения, связанных с обработкой визуальной информации.

**Зачем нужен OpenCV?**
- **Обработка изображений**: OpenCV позволяет легко манипулировать изображениями: изменять размер, обрезать, вращать, изменять цвета, применять различные фильтры.
- **Компьютерное зрение**: это основная сфера применения OpenCV. Библиотека предоставляет инструменты для распознавания объектов, лиц, отслеживания движущихся объектов, анализа изображений и видео.
- **Машинное обучение**: OpenCV включает в себя модули для работы с простыми алгоритмами машинного обучения, такими как классификация, кластеризация, регрессия, и может быть использован для построения более сложных систем.

Применение OpenCV охватывает огромное количество сфер, таких как:
- **Безопасность**: системы видеонаблюдения, распознавание лиц.
- **Автономные автомобили**: анализ окружающей среды с помощью камер.
- **Медицинская диагностика**: обработка медицинских изображений (рентген, МРТ).
- **Робототехника**: ориентация роботов в пространстве с использованием визуальной информации.

### История создания OpenCV

OpenCV был разработан в 1999 году компанией **Intel**. Главной целью было создание универсальной библиотеки, которая позволяла бы разрабатывать алгоритмы компьютерного зрения для широкого круга приложений. В то время подобные решения были дорогими и сложными для использования, и библиотека OpenCV должна была упростить эту задачу.

- **1999 год** — OpenCV был запущен как проект с открытым исходным кодом, изначально ориентированный на исследовательские и научные работы в области компьютерного зрения.
- **2000-е годы** — библиотека быстро набирала популярность среди разработчиков и исследователей, так как предоставляла доступ к передовым методам обработки изображений и алгоритмам компьютерного зрения, а также могла быть использована в реальных приложениях.
- **2010-е годы** — проект продолжал развиваться, улучшалась поддержка различных операционных систем, языков программирования и типов оборудования (от мобильных устройств до серверов и встраиваемых систем). В это время OpenCV стал одним из самых популярных инструментов для создания приложений в области обработки изображений.
- **Сегодня** — OpenCV активно используется по всему миру, с ним работают как исследователи, так и профессиональные разработчики. Библиотека поддерживает самые новые достижения в области машинного обучения и искусственного интеллекта.

Благодаря своей открытости и доступности, OpenCV быстро занял лидирующую позицию среди инструментов для решения задач в области компьютерного зрения.

### Основные возможности библиотеки

OpenCV предлагает огромный спектр функций, охватывающих самые разные области работы с изображениями и видео. Рассмотрим основные из них:

#### 1. **Обработка изображений**
OpenCV предоставляет множество инструментов для работы с изображениями на низком уровне:
- **Чтение и запись изображений**: Библиотека поддерживает широкий набор форматов изображений, таких как BMP, JPEG, PNG, TIFF и другие.
- **Изменение размера и преобразование**: функции для изменения размера изображения (`cv2.resize`), поворота, обрезки и изменения ориентации.
- **Цветовые преобразования**: OpenCV поддерживает различные цветовые пространства, такие как RGB, BGR, HSV, Lab, что позволяет эффективно работать с изображениями в различных цветовых моделях.
- **Фильтрация изображений**: различные фильтры для улучшения качества изображений, например, гауссово размытие (`cv2.GaussianBlur`), медианное размытие, фильтрация с использованием ядра.

#### 2. **Анализ и обработка видео**
OpenCV также предоставляет возможности для работы с видео:
- **Чтение видеофайлов**: Можно работать с видеофайлами, обрабатывать их кадры и извлекать информацию с помощью `cv2.VideoCapture`.
- **Запись видео**: OpenCV позволяет записывать видео в различные форматы, используя `cv2.VideoWriter`.
- **Обработка в реальном времени**: обработка видео в реальном времени (например, в системах видеонаблюдения или роботах с камерами) — важная возможность OpenCV.

#### 3. **Распознавание объектов**
Одной из наиболее важных функций является распознавание объектов:
- **Обнаружение лиц и объектов**: OpenCV предоставляет готовые алгоритмы для детекции лиц и других объектов с помощью каскадных классификаторов, таких как `cv2.CascadeClassifier`.
- **Обнаружение контуров**: Библиотека может находить контуры объектов на изображении с помощью функции `cv2.findContours` и позволять извлекать геометрическую информацию о них.
- **Детектирование движущихся объектов**: OpenCV поддерживает алгоритмы для отслеживания объектов в видео, например, с помощью алгоритмов Кана или детекторов, таких как `cv2.BackgroundSubtractor`.

#### 4. **Машинное обучение и ИИ**
OpenCV также интегрирован с алгоритмами машинного обучения, что позволяет использовать его для более сложных задач:
- **Классификация**: использование классификаторов для распознавания образцов (например, на основе обученных моделей).
- **Кластеризация и регрессия**: OpenCV включает алгоритмы для кластеризации и регрессии для анализа данных.
- **Глубокое обучение**: начиная с версии 3.0, OpenCV предоставляет поддержку для работы с глубокими нейронными сетями через модуль DNN, что позволяет интегрировать модели из популярных фреймворков, таких как TensorFlow и Caffe.

#### 5. **Геометрия и трансформации**
OpenCV включает функционал для работы с геометрией изображений:
- **Преобразования изображения**: использование аффинных и перспективных преобразований для деформации изображений и корректировки перспективы.
- **Проекция и восстановление 3D**: OpenCV может быть использован для восстановления трехмерных сцен из нескольких двумерных изображений, что находит применение в области компьютерного зрения и робототехники.

#### 6. **Поддержка мобильных устройств**
С OpenCV можно разрабатывать приложения для мобильных платформ (Android, iOS), что делает его полезным инструментом для создания мобильных приложений с функциями распознавания и анализа изображений в реальном времени.

## 2. Установка OpenCV

### Установка OpenCV с использованием pip

1. Откройте командную строку или терминал.
2. Выполните команду для установки основной версии OpenCV:

```bash
pip install opencv-python
```

Эта команда установит **основную версию** OpenCV, которая включает в себя все необходимые функции для работы с изображениями, видео и базовым компьютерным зрением. 

3. Если вам нужна версия OpenCV с дополнительными функциями и модулями, например, для работы с алгоритмами компьютерного зрения, машинами или расширенными методами обработки, то нужно установить пакет с дополнительными модулями:

```bash
pip install opencv-contrib-python
```

Этот пакет включает в себя не только основные функции OpenCV, но и дополнительные модули, которые не включены в стандартную версию, например, **собственные алгоритмы для машинного зрения** и некоторые специальные инструменты, такие как более сложные классификаторы и методы для обработки данных.

### Проверка установки: импорт библиотеки в Python

После того как вы успешно установили OpenCV, важно проверить, что установка прошла правильно и что библиотека доступна для использования в вашем проекте.

Импортируйте OpenCV и выведите текущую версию установленного пакета:

```python
import cv2
print(cv2.__version__)
```

Если установка прошла успешно, вы не получите никаких ошибок, и Python просто загрузит библиотеку. В случае, если OpenCV не установлен или возникла проблема с установкой, вы получите сообщение об ошибке.

## 3. Основные структуры данных OpenCV

### Изображения (матрицы изображений)

В **OpenCV** изображения представляют собой двумерные матрицы, где каждый элемент (или пиксель) содержит информацию о цвете и яркости изображения. Это основная структура данных, с которой работает OpenCV при обработке изображений.

#### 1. **Типы данных в OpenCV**

OpenCV использует **матрицы (numpy arrays)** для хранения изображений. Каждое изображение в OpenCV представлено как объект класса `cv2.Mat`, который можно воспринимать как массив данных. Важно понимать, что изображения могут храниться в разных форматах и типах данных, в зависимости от того, с каким типом изображения мы работаем.

**Типы данных** для хранения изображений:
- **Целые числа (int)**: Чаще всего используются целые числа для представления значений яркости пикселей (от 0 до 255).
- **Вещественные числа (float)**: Для некоторых типов операций, таких как обработки с высоким динамическим диапазоном, используется формат с плавающей точкой.

Рассмотрим подробнее, как типы данных влияют на изображение:

- **8-битный (CV_8U)**: Для большинства изображений этот формат подходит. Он использует значения от 0 до 255 для каждого канала изображения.
- **32-битный (CV_32F)**: Для более сложных вычислений, таких как фильтрация или работа с высококачественными изображениями, используется формат с плавающей точкой.

Пример:
```python
import cv2
import numpy as np

# Чтение изображения
image = cv2.imread('image.jpg')

# Получение типа данных изображения
print(image.dtype)
```
В этом примере `image.dtype` может вернуть тип данных, например `uint8` (8-битный без знака), который обозначает стандартный формат пикселей изображения.

#### 2. **Цветовые пространства (RGB, BGR, HSV)**

Цветовые пространства — это способ представления цвета, который используется для обработки и анализа изображений. В OpenCV поддерживаются несколько цветовых пространств, каждое из которых имеет свои особенности и области применения.

- **BGR (Blue, Green, Red)**: Это основное цветовое пространство, которое использует OpenCV для хранения цветных изображений. Когда вы загружаете изображение через `cv2.imread()`, оно будет представлено в пространстве **BGR**, а не **RGB**, как это происходит в большинстве других библиотек.
  - Канал **Blue** хранит значения синего цвета.
  - Канал **Green** хранит значения зеленого цвета.
  - Канал **Red** хранит значения красного цвета.

```python
# Пример работы с BGR
image = cv2.imread('image.jpg')
print(image.shape)  # (height, width, 3) - три канала (B, G, R)
```

- **RGB (Red, Green, Blue)**: Это стандартное цветовое пространство для отображения цветов на экранах. В OpenCV для работы с изображениями в RGB вам нужно выполнить преобразование из BGR в RGB.
  - Преобразование из BGR в RGB выполняется с помощью функции `cv2.cvtColor()`.

```python
image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
```

- **HSV (Hue, Saturation, Value)**: Это цветовое пространство, которое более интуитивно понятно для человека. В отличие от RGB, которое основано на аддитивном смешении цветов, HSV разделяет изображение на три компонента:
  - **Hue (оттенок)** — определяет тип цвета (например, красный, синий, зеленый).
  - **Saturation (насыщенность)** — степень насыщенности цвета.
  - **Value (яркость)** — яркость цвета.
  
  Это пространство полезно, когда нужно выделить объекты на изображении по цвету, независимо от освещенности.

```python
image_hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
```

- **Grayscale (Оттенки серого)**: Изображение, представленное в градациях серого, использует только один канал для хранения интенсивности света (от 0 до 255). Этот формат используется для упрощенных задач, например, для выделения контуров или обработки изображения без учета цвета.

```python
gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
```

#### 3. **Цветовые преобразования**

Для преобразования изображений из одного цветового пространства в другое OpenCV предоставляет функцию `cv2.cvtColor()`, которая позволяет менять цвета с учетом специфики каждого пространства.

Примеры:
```python
# Преобразование из BGR в RGB
image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

# Преобразование из BGR в HSV
image_hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)

# Преобразование из BGR в серый
gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
```

Цветовые преобразования играют важную роль в задачах компьютерного зрения, так как они позволяют выделить нужные характеристики изображения, такие как цветовые особенности или яркость, и упростить анализ.

### Работа с изображениями как с массивами NumPy

В OpenCV изображения являются просто **массивами NumPy** — двумерными или трехмерными матрицами, где каждый элемент представляет собой значение пикселя. Для обработки и анализа изображений можно использовать мощные средства библиотеки **NumPy**, что делает работу с изображениями гибкой и эффективной.

#### 1. **Структура изображения как массива**

Каждое изображение в OpenCV представлено как массив NumPy, где:
- **Для цветных изображений**: изображение представляется как **трехмерный массив** (высота, ширина, количество каналов).
- **Для черно-белых изображений**: изображение представляется как **двухмерный массив** (высота, ширина).

Например, изображение размером 300x400 пикселей с 3 каналами (RGB) будет представлено как массив размером `(300, 400, 3)`, где:
- `300` — высота изображения.
- `400` — ширина изображения.
- `3` — количество каналов (RGB).

#### 2. **Доступ к пикселям изображения**

Каждый пиксель изображения можно получить или изменить, обратившись к соответствующему элементу массива. Индексы в OpenCV всегда начинаются с 0.

- **Для цветного изображения (BGR)**:
  - Чтобы получить цвет пикселя на позиции (x, y), мы можем обратиться к этому пикселю следующим образом:
    ```python
    pixel = image[y, x]
    print(pixel)  # [B, G, R]
    ```
    Например, для изображения размером 3x3 пикселя:
    ```python
    pixel = image[1, 1]  # Получение пикселя в центре изображения
    print(pixel)  # [120, 100, 150] — значения для каналов B, G, R
    ```

- **Для серого изображения**:
  - Для черно-белых изображений доступ к пикселям аналогичен, но массив будет двумерным, и каждый пиксель будет иметь одно значение (интенсивность света):
    ```python
    gray_pixel = gray_image[y, x]
    print(gray_pixel)  # 128 — интенсивность серого цвета
    ```

#### 3. **Изменение пикселей изображения**

Можно также изменять отдельные пиксели или даже части изображения:

```python
# Изменить цвет пикселя
image[100, 200] = [255, 0, 0]  # Сделать пиксель синим (BGR)
```

Чтобы изменить все пиксели в изображении, можно использовать slicing (срезы) массива:

```python
# Обрезать изображение (вырезать часть изображения)
cropped_image = image[50:150, 100:200]  # Обрезаем участок (50:150, 100:200)
```

#### 4. **Математические операции с изображениями**

Из-за того, что изображения в OpenCV являются массивами NumPy, можно легко применять математические операции ко всему изображению или его части. Например:
- Добавить яркость ко всему изображению:
  ```python
  image = cv2.add(image, (50, 50, 50))  # Увеличение яркости на 50 для всех каналов
  ```
- Применить маску или фильтрацию:
  ```python
  blurred_image = cv2.GaussianBlur(image, (5, 5), 0)  # Размытие изображения
  ```

## 4. Основные операции с изображениями

Работа с изображениями в **OpenCV** основывается на выполнении нескольких базовых операций: чтение, отображение, сохранение, а также манипуляции с пикселями и матрицами изображений. Эти операции являются основой для создания более сложных алгоритмов в области обработки изображений. 

### 1. **Чтение изображений**

**Чтение изображения** — это процесс загрузки файла изображения в память, чтобы можно было его обрабатывать в программе. OpenCV предоставляет удобную функцию `cv2.imread()`, которая позволяет считывать изображения из файлов в различные форматы, такие как JPEG, PNG, BMP и другие.

**Синтаксис:**
```python
image = cv2.imread('путь_к_файлу')
```

**Пояснение**:
- Функция `cv2.imread()` загружает изображение в память и представляет его как **матрицу** (NumPy массив).
- Параметр **путь_к_файлу** указывает местоположение файла на диске. Убедитесь, что указали правильный путь.

**Пример:**
```python
import cv2

# Загрузка изображения
image = cv2.imread('image.jpg')

# Проверка успешности загрузки
if image is None:
    print("Не удалось загрузить изображение!")
else:
    print("Изображение успешно загружено.")
```

**Режимы чтения**:
- **cv2.IMREAD_COLOR** (по умолчанию) — читает изображение в цвете (цветное изображение в BGR).
- **cv2.IMREAD_GRAYSCALE** — читает изображение в оттенках серого.
- **cv2.IMREAD_UNCHANGED** — читает изображение в оригинальном формате, включая альфа-канал (прозрачность).

Пример чтения изображения в градациях серого:
```python
image_gray = cv2.imread('image.jpg', cv2.IMREAD_GRAYSCALE)
```

### 2. **Отображение изображений**

**Отображение изображения** в OpenCV осуществляется с помощью функции `cv2.imshow()`. Это полезно для визуального контроля результата обработки изображений, а также для отладки.

**Синтаксис:**
```python
cv2.imshow('Window Name', image)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

**Пояснение**:
- **'Window Name'** — имя окна, в котором будет отображаться изображение. Это может быть любое строковое значение.
- **cv2.imshow()** — показывает изображение в отдельном окне.
- **cv2.waitKey(0)** — эта команда приостанавливает выполнение программы, пока не будет нажата клавиша. Если аргументом передать число, то программа будет ожидать указанное количество миллисекунд, прежде чем продолжить выполнение.
- **cv2.destroyAllWindows()** — закрывает все окна, созданные функцией `cv2.imshow()`.

**Пример:**
```python
import cv2

# Загрузка изображения
image = cv2.imread('image.jpg')

# Отображение изображения
cv2.imshow('Loaded Image', image)

# Ожидание нажатия клавиши и закрытие окна
cv2.waitKey(0)
cv2.destroyAllWindows()
```

**Пояснение**:
- После вызова `cv2.imshow()` изображение появится в отдельном окне с указанным именем.
- Окно останется открытым до тех пор, пока пользователь не нажмёт клавишу, после чего окно будет закрыто.

### 3. **Сохранение изображений**

После обработки изображения часто возникает необходимость сохранить результат на диск. В OpenCV это делается с помощью функции `cv2.imwrite()`.

**Синтаксис:**
```python
cv2.imwrite('путь_к_файлу', image)
```

**Пояснение**:
- **'путь_к_файлу'** — это путь, куда будет сохранено изображение. Вы можете указать имя файла и расширение, например `output.jpg` или `result.png`.
- **image** — это матрица изображения, которую нужно сохранить.

**Пример:**
```python
import cv2

# Загрузка изображения
image = cv2.imread('image.jpg')

# Сохранение изображения в новый файл
cv2.imwrite('output.jpg', image)
```

**Пояснение**:
- В этом примере изображение, которое было загружено в переменную `image`, будет сохранено в файл `output.jpg` в текущем рабочем каталоге.
- OpenCV поддерживает множество форматов, включая `.jpg`, `.png`, `.bmp`, `.tiff`.

> **Важное замечание**:
> Функция `cv2.imwrite()` возвращает **True**, если изображение было успешно сохранено, или **False**, если произошла ошибка (например, неверный путь или разрешения на запись).

### 4. **Основные манипуляции с изображениями**

Теперь, когда мы разобрались с базовыми операциями, давайте рассмотрим несколько распространённых манипуляций, которые можно выполнить с изображениями в OpenCV.

#### 1. **Изменение размера изображения**

Для изменения размера изображения используется функция `cv2.resize()`. Это полезно, например, если нужно адаптировать изображение под заданный размер.

**Синтаксис:**
```python
resized_image = cv2.resize(image, (ширина, высота))
```

**Пояснение**:
- Функция принимает два параметра: **ширину** и **высоту** нового изображения.
- Можно использовать параметры для сохранения пропорций изображения, используя аргумент `fx` или `fy` (коэффициенты масштабирования по горизонтали и вертикали).

**Пример:**
```python
resized_image = cv2.resize(image, (800, 600))  # Растягиваем изображение до 800x600 пикселей
cv2.imshow('Resized Image', resized_image)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

#### 2. **Обрезка изображения**

Обрезка изображения или извлечение его части — это процесс получения подмассива изображения. В OpenCV для этого используется синтаксис срезов.

**Пример:**
```python
# Обрезаем область изображения с координатами от (100, 100) до (300, 300)
cropped_image = image[100:300, 100:300]
cv2.imshow('Cropped Image', cropped_image)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

**Пояснение**:
- В примере выше мы извлекаем часть изображения, начиная с 100 пикселей по горизонтали и вертикали и заканчивая 300 пикселями.

#### 3. **Преобразования изображений**

OpenCV предлагает множество методов для преобразования изображений, например:
- **Поворот изображения**:
  ```python
  # Поворот изображения на 90 градусов
  rotated_image = cv2.rotate(image, cv2.ROTATE_90_CLOCKWISE)
  ```

- **Изменение яркости**:
  Для изменения яркости изображения можно прибавить или отнять значение от всех пикселей изображения:
  ```python
  brightness_adjusted = cv2.add(image, (50, 50, 50))  # Увеличиваем яркость на 50 для каждого канала
  ```

- **Применение фильтров**:
  Например, размытие изображения с помощью Гауссова фильтра:
  ```python
  blurred_image = cv2.GaussianBlur(image, (5, 5), 0)
  ```
## 5. Работа с цветами и каналами изображения

Одной из основных задач при обработке изображений является манипуляция с цветами и каналами изображения. В OpenCV есть множество методов для изменения цветового пространства, а также для применения различных фильтров, которые могут изменять или улучшать цвета и текстуры изображения. 

### 1. **Изменение цветового пространства**

Цветовое пространство определяет, как цвета кодируются и отображаются в изображении. OpenCV позволяет легко менять цветовое пространство изображения, преобразуя его между различными форматами, такими как BGR, RGB, HSV, Lab, и другими.

#### Преобразование цветового пространства с использованием `cv2.cvtColor()`

Основной функцией для преобразования цветовых пространств является **`cv2.cvtColor()`**. Эта функция принимает два аргумента:
- Изображение, которое нужно преобразовать.
- Код преобразования, определяющий, в какое цветовое пространство нужно преобразовать изображение.

##### Примеры преобразований:

- **BGR в RGB**:
  OpenCV по умолчанию работает с изображениями в пространстве **BGR**, однако в некоторых случаях, например при работе с библиотеками для отображения изображений, таких как Matplotlib, требуется преобразовать изображение в пространство **RGB**.
  ```python
  image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
  ```

- **BGR в Grayscale (Оттенки серого)**:
  Для работы с черно-белыми изображениями часто необходимо преобразовать цветное изображение в **градации серого**. Это делается с помощью преобразования в **Grayscale** (оттенки серого).
  ```python
  gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
  ```

- **BGR в HSV**:
  Цветовое пространство **HSV** (оттенок, насыщенность, яркость) позволяет работать с изображениями на более высоком уровне, часто более интуитивно понятном для человека. Например, для выделения объектов по цвету, в отличие от RGB, где цвета могут быть скрытыми из-за освещенности.
  ```python
  image_hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
  ```

- **BGR в Lab**:
  Пространство **Lab** (L - светлота, a - зелёный-красный, b - синий-жёлтый) является еще одной альтернативой для работы с цветами. Оно более близко к восприятию человеком и полезно для выделения деталей в условиях разного освещения.
  ```python
  image_lab = cv2.cvtColor(image, cv2.COLOR_BGR2Lab)
  ```

#### Преобразования между цветовыми пространствами

В зависимости от задачи, вы можете преобразовать изображение между различными цветовыми пространствами для улучшения результатов обработки или для удобства выполнения дальнейших шагов.

##### Пример: Преобразование из BGR в HSV и выделение определённого диапазона цветов

```python
import cv2
import numpy as np

# Чтение изображения
image = cv2.imread('image.jpg')

# Преобразование в HSV
image_hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)

# Установка диапазона для поиска синего цвета
lower_blue = np.array([100, 150, 0])  # Нижний предел (оттенок, насыщенность, яркость)
upper_blue = np.array([140, 255, 255])  # Верхний предел

# Маска, которая находит все пиксели в указанном диапазоне синего
mask = cv2.inRange(image_hsv, lower_blue, upper_blue)

# Применение маски к изображению
result = cv2.bitwise_and(image, image, mask=mask)

# Отображение результата
cv2.imshow('Detected Blue', result)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

В этом примере мы преобразуем изображение в HSV и выделяем пиксели, которые находятся в пределах синего цвета. Маска применяется для фильтрации этих пикселей, и мы видим только те участки изображения, которые соответствуют синему цвету.

---

### 2. **Применение фильтров (например, сглаживание) с помощью OpenCV**

Фильтры в OpenCV используются для изменения свойств изображения, таких как улучшение резкости, уменьшение шума или выделение контуров. Один из самых распространённых фильтров — это фильтр **сглаживания**, который используется для размытия изображения.

#### Сглаживание изображений

Сглаживание помогает уменьшить шум и детализацию изображения. В OpenCV для этого используются различные методы фильтрации, такие как **Гауссово размытие** (Gaussian Blur), **Среднее размытие** (Average Blur) и **Медианное размытие** (Median Blur).

##### 1. **Гауссово размытие**

Гауссов фильтр помогает уменьшить шум в изображении, используя математическую функцию Гаусса для размытия изображения. Он действует плавно и удаляет небольшие детали, сохраняя более крупные структуры.

```python
# Гауссово размытие изображения
blurred_image = cv2.GaussianBlur(image, (5, 5), 0)
```

**Пояснение**:
- Параметры:
  - `(5, 5)` — это размер ядра фильтра. Чем больше размер ядра, тем сильнее размытие. Оно должно быть нечётным числом.
  - `0` — это стандартное отклонение по Гауссу. Когда его значение равно нулю, OpenCV сам вычисляет его на основе размера ядра.

##### Пример:
```python
import cv2

# Загрузка изображения
image = cv2.imread('image.jpg')

# Применение Гауссова размытия
blurred_image = cv2.GaussianBlur(image, (7, 7), 0)

# Отображение результата
cv2.imshow('Blurred Image', blurred_image)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

##### 2. **Среднее размытие (Average Blur)**

Среднее размытие заменяет каждый пиксель на среднее значение пикселей в окне, окружающем его. Этот метод может быть полезен для удаления шума, но не всегда даёт такие же хорошие результаты, как Гауссово размытие.

```python
# Среднее размытие
average_blurred_image = cv2.blur(image, (5, 5))
```

##### 3. **Медианное размытие (Median Blur)**

Медианное размытие заменяет каждый пиксель на медиану значений всех пикселей в окне. Этот метод особенно полезен для удаления "солевого" и "перцевого" шума, где пиксели имеют значения, значительно отличающиеся от окружающих пикселей.

```python
# Медианное размытие
median_blurred_image = cv2.medianBlur(image, 5)
```

#### 3. **Использование фильтров для улучшения резкости**

Хотя размытие помогает уменьшить шум, иногда необходимо улучшить резкость изображения, чтобы подчеркнуть детали. Для этого в OpenCV есть фильтры для повышения контраста и резкости.

Повышение резкости делает изображение более контрастным, усиливая границы объектов. Для этого используется фильтр, который выделяет резкие переходы между пикселями.

```python
import numpy as np

# Создание ядра для повышения резкости
kernel = np.array([[-1, -1, -1],
                   [-1,  9, -1],
                   [-1, -1, -1]])

# Применение фильтра к изображению
sharpened_image = cv2.filter2D(image, -1, kernel)

# Отображение результата
cv2.imshow('Sharpened Image', sharpened_image)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

**Пояснение**:
- Ядро **kernel** для повышения резкости содержит значения, которые вычисляют разницу между пикселями. Центральное значение 9 значительно увеличивает контраст, а отрицательные значения вокруг него помогают выделить детали.

## 6. Основные операторы обработки изображений

В OpenCV существуют множество базовых операций для обработки изображений. Основные из них включают манипуляции с пикселями изображения и использование пороговых значений для выделения объектов или фрагментов изображения. Эти операции лежат в основе более сложных алгоритмов обработки изображений и компьютерного зрения.

### 1. **Операции с пикселями**

Каждое изображение в OpenCV представлено в виде матрицы, где каждый элемент этой матрицы — это пиксель изображения. Операции с пикселями — это фундаментальные операции, которые позволяют изменять изображение на уровне отдельных пикселей.

#### Доступ к пикселям изображения

Изображения в OpenCV, как правило, представлены в виде объектов **NumPy массивов**. Каждый пиксель изображения можно получить или изменить через его индекс в массиве. Операции с пикселями — это прямое обращение к этим элементам массива.

##### Пример доступа и изменения пикселя:
```python
import cv2

# Чтение изображения
image = cv2.imread('image.jpg')

# Доступ к пикселю по индексам [строка, колонка]
pixel = image[100, 100]  # Получаем значение пикселя на позиции (100, 100)

# Печать значений цвета пикселя (BGR)
print(pixel)  # Например, [255, 0, 0] для красного пикселя (в пространстве BGR)

# Изменение значения пикселя
image[100, 100] = [0, 255, 0]  # Заменяем на зеленый пиксель (BGR)
```

**Пояснение**:
- В этом примере мы используем индексирование массива NumPy для доступа к пикселям изображения. Позиция пикселя указана в виде `(строка, колонка)`, то есть по вертикали (строка) и по горизонтали (колонка).
- Пиксель в изображении — это массив из трех значений, представляющих **BGR** (синий, зелёный, красный) каналы.
- Мы можем не только читать, но и изменять значения пикселей. Это позволяет, например, окрашивать изображения в определённые цвета, выделять объекты и выполнять другие операции.

#### Операции над пикселями

С помощью операций с пикселями можно выполнять различные манипуляции, например:
- **Изменение яркости**: можно прибавить или вычесть значение из всех пикселей изображения.
- **Инвертирование цветов**: можно инвертировать цвета, например, для создания эффекта негатива изображения.

##### Пример изменения яркости:
```python
# Увеличиваем яркость изображения
brightened_image = cv2.convertScaleAbs(image, alpha=1, beta=50)
cv2.imshow('Brightened Image', brightened_image)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

**Пояснение**:
- Функция `cv2.convertScaleAbs()` позволяет масштабировать и добавлять значение ко всем пикселям изображения. Аргумент `alpha` контролирует контраст, а `beta` — яркость. В данном примере мы увеличиваем яркость на 50 для каждого пикселя.

##### Пример инвертирования изображения:
```python
# Инвертируем цвета изображения
inverted_image = cv2.bitwise_not(image)
cv2.imshow('Inverted Image', inverted_image)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

**Пояснение**:
- Функция `cv2.bitwise_not()` выполняет побитовую инверсию каждого пикселя изображения. Это преобразует все белые пиксели в черные, а все черные — в белые, создавая эффект негатива изображения.

---

### 2. **Применение пороговых значений**

Пороговые операции являются одним из самых распространенных инструментов в обработке изображений. Они используются для выделения интересующих объектов или областей изображения на основе их интенсивности (яркости). Суть пороговой операции заключается в том, что все пиксели изображения, которые имеют значения яркости выше или ниже заданного порога, принимают значение белого или черного, а остальные — наоборот.

#### Основная идея пороговой операции

Пороговая операция позволяет преобразовать **цветное изображение** в **черно-белое** (бинарное), выделяя объекты с яркостью выше или ниже заданного порога. В OpenCV это делается с помощью функции **`cv2.threshold()`**.

##### Синтаксис:
```python
ret, thresh_image = cv2.threshold(image, threshold_value, max_value, threshold_type)
```

- **image**: исходное изображение, которое обычно конвертируется в оттенки серого перед пороговой операцией.
- **threshold_value**: значение порога, выше которого пиксели будут установлены в максимальное значение.
- **max_value**: значение, которое будет присвоено пикселям, если их значение выше порога.
- **threshold_type**: тип пороговой операции. Может быть:
  - `cv2.THRESH_BINARY` — простая бинаризация: пиксели выше порога становятся максимальными, а остальные — нулями.
  - `cv2.THRESH_BINARY_INV` — инверсия бинарной операции.
  - `cv2.THRESH_TRUNC` — пиксели, превышающие порог, обрезаются.
  - `cv2.THRESH_TOZERO` — пиксели ниже порога становятся нулями.

##### Пример бинаризации изображения:
```python
# Чтение изображения и преобразование в оттенки серого
image_gray = cv2.imread('image.jpg', cv2.IMREAD_GRAYSCALE)

# Применение пороговой операции
ret, thresh_image = cv2.threshold(image_gray, 127, 255, cv2.THRESH_BINARY)

# Отображение результата
cv2.imshow('Threshold Image', thresh_image)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

**Пояснение**:
- В этом примере изображение сначала конвертируется в **градации серого** с помощью `cv2.IMREAD_GRAYSCALE`, чтобы мы могли работать только с интенсивностью света (яркостью).
- Мы применяем пороговое значение 127. Все пиксели с яркостью выше 127 становятся белыми (255), а все пиксели с яркостью ниже 127 — черными (0). Это помогает выделить объекты с высокой яркостью на фоне темных участков.

##### Пример инвертирования порогового изображения:
```python
# Применение инвертированного порога
ret, thresh_inv_image = cv2.threshold(image_gray, 127, 255, cv2.THRESH_BINARY_INV)

# Отображение инвертированного результата
cv2.imshow('Inverted Threshold Image', thresh_inv_image)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

**Пояснение**:
- В данном случае инвертируется результат пороговой операции. Теперь все пиксели с яркостью ниже 127 становятся белыми, а те, что выше — черными.

#### 3. **Операции с пороговыми значениями для выделения объектов**

Пороговые операции особенно полезны для выделения объектов на изображении. Например, можно выделить области с высоким контрастом или определенным цветом (например, только синие или красные участки). Такой подход активно используется в задачах **поиск контуров** и **выделение объектов**.

##### Пример: Использование порогового значения для выделения объектов:
```python
import numpy as np
import cv2

# Чтение изображения
image = cv2.imread('image.jpg')

# Преобразование в оттенки серого
gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# Применение порога для выделения объектов
ret, thresh_image = cv2.threshold(gray_image, 120, 255, cv2.THRESH_BINARY)

# Отображение изображения с порогом
cv2.imshow('Threshold Objects', thresh_image)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

**Пояснение**:
- Мы выделяем все участки изображения, где яркость пикселей выше 120, и делаем их белыми, а все остальные — черными. Это помогает выделить объекты с высокой яркостью на фоне тёмных.

## 7. Детектирование границ и контуров

Детектирование границ и контуров — это одна из самых важных задач в компьютерном зрении, которая используется для анализа структуры изображения, распознавания объектов и их выделения. В OpenCV для этой цели существуют различные методы, включая использование оператора Канни для поиска границ и алгоритм для поиска контуров. Также существует возможность работы с иерархией контуров, что полезно для организации контуров, особенно в случае вложенных объектов.

### 1. **Применение оператора Канни для поиска границ**

Оператор Канни — это один из наиболее популярных алгоритмов для поиска границ в изображениях. Он использует принцип выявления изменений интенсивности пикселей для нахождения границ объектов, что делает его мощным инструментом для сегментации изображений.

#### Принцип работы оператора Канни

Алгоритм Канни состоит из нескольких этапов:
1. **Сглаживание изображения** — для удаления шума используется Гауссово размытие.
2. **Градиентный анализ** — вычисляются градиенты изображения для нахождения изменений интенсивности.
3. **Нахождение локальных экстремумов** — пиксели, которые являются локальными максимумами вдоль направления градиента, выделяются как границы.
4. **Пороговая фильтрация** — применяется два порога для разделения пикселей на слабые и сильные границы, и, на основе этого, с использованием гистерезиса определяется окончательное положение границ.

#### Как применить оператор Канни в OpenCV

В OpenCV для применения оператора Канни используется функция **`cv2.Canny()`**. Эта функция требует два пороговых значения, чтобы классифицировать пиксели как сильные или слабые границы.

##### Синтаксис:
```python
edges = cv2.Canny(image, threshold1, threshold2)
```
- **image** — изображение в оттенках серого (градации серого).
- **threshold1** — первый порог для слабых границ.
- **threshold2** — второй порог для сильных границ.

##### Пример использования оператора Канни:

```python
import cv2

# Чтение изображения и преобразование в оттенки серого
image = cv2.imread('image.jpg')
gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# Применение оператора Канни
edges = cv2.Canny(gray_image, 100, 200)

# Отображение результата
cv2.imshow('Edges', edges)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

**Пояснение**:
- Сначала изображение преобразуется в **оттенки серого**, так как детектирование границ обычно выполняется только на основе интенсивности (яркости) пикселей.
- Функция **`cv2.Canny()`** применяет алгоритм Канни с порогами 100 и 200. Эти пороги определяют, какие изменения интенсивности пикселей будут восприниматься как границы. Если разница между пикселями больше первого порога (100), они считаются сильными границами. Если разница меньше второго порога (200), но всё ещё значительна, эти пиксели считаются слабой границей и могут быть сохранены, если они связаны с сильной границей.

Оператор Канни позволяет детектировать контуры объектов, выделяя их границы, и применяется в множестве задач, таких как распознавание объектов, выделение объектов на изображении и фильтрация.

---

### 2. **Поиск контуров**

После того как границы на изображении найдены, следующим шагом является **поиск контуров**. Контуры — это последовательности точек, которые соединяются и образуют "границу" объекта, то есть линии, очерчивающие объекты на изображении.

#### Алгоритм поиска контуров

В OpenCV для поиска контуров используется функция **`cv2.findContours()`**. Она обнаруживает контуры на бинарном изображении (где все пиксели либо белые, либо черные).

##### Синтаксис:
```python
contours, hierarchy = cv2.findContours(image, mode, method)
```
- **image** — бинарное изображение, на котором нужно искать контуры (изображение должно быть в формате черно-белого).
- **mode** — метод, который определяет, как должны быть организованы найденные контуры. Возможные значения:
  - `cv2.RETR_EXTERNAL` — только внешние контуры.
  - `cv2.RETR_LIST` — все контуры, но без иерархии.
  - `cv2.RETR_TREE` — все контуры, с полной иерархией.
  - `cv2.RETR_CCOMP` — все контуры, организованные в два уровня (внешние и внутренние).
- **method** — метод, используемый для приближения контуров:
  - `cv2.CHAIN_APPROX_SIMPLE` — хранит только концы контуров, устраняя лишние точки.
  - `cv2.CHAIN_APPROX_NONE` — сохраняет все точки, входящие в контур.

##### Пример поиска и отображения контуров:
```python
import cv2

# Чтение изображения и преобразование в оттенки серого
image = cv2.imread('image.jpg')
gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# Применение порога для бинаризации изображения
ret, thresh_image = cv2.threshold(gray_image, 127, 255, cv2.THRESH_BINARY)

# Поиск контуров
contours, hierarchy = cv2.findContours(thresh_image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Отображение контуров
cv2.drawContours(image, contours, -1, (0, 255, 0), 3)  # Рисуем контуры на исходном изображении

# Отображение изображения с контурами
cv2.imshow('Contours', image)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

**Пояснение**:
- Сначала изображение преобразуется в **градации серого**, затем применяется **пороговая операция** для бинаризации, чтобы сделать его черно-белым.
- Функция **`cv2.findContours()`** находит контуры на бинаризованном изображении. Мы выбираем `cv2.RETR_EXTERNAL` для поиска только внешних контуров, и `cv2.CHAIN_APPROX_SIMPLE` для упрощения контуров (сохранение только необходимых точек).
- После нахождения контуров мы рисуем их на оригинальном изображении с помощью функции **`cv2.drawContours()`**.

Контуры могут быть использованы для различных задач, таких как определение формы объектов, подсчет их количества, сегментация объектов и т.д.

---

### 3. **Иерархия контуров и способы работы с ней**

Иерархия контуров в OpenCV — это структура данных, которая хранит информацию о взаимных отношениях между контурами. Это особенно полезно, когда объекты на изображении имеют вложенные структуры (например, контуры внутри контуров), и важно понимать, какой контур является внешним, а какой — внутренним.

#### Что такое иерархия контуров?

Иерархия контуров представляет собой информацию о вложенности каждого контура. Например, если один контур находится внутри другого, это будет отражено в иерархии. Для каждого контура иерархия хранит информацию о:
- **parent** (родитель) — индекс контуров, который является внешним для текущего.
- **child** (потомок) — индекс вложенных контуров внутри текущего.
- **previous** (предыдущий) — индекс предыдущего контура на том же уровне.
- **next** (следующий) — индекс следующего контура на том же уровне.

#### Как работать с иерархией?

Иерархия контуров возвращается как дополнительный результат вместе с контурами в функции **`cv2.findContours()`**. Для работы с иерархией можно использовать индексы, чтобы анализировать, как контуры расположены друг относительно друга.

##### Пример работы с иерархией контуров:
```python
import cv2

# Чтение изображения и преобразование в оттенки серого
image = cv2.imread('image.jpg')
gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# Применение порога для бинаризации изображения
ret, thresh_image = cv2.threshold(gray_image, 127, 255, cv2.THRESH_BINARY)

# Поиск контуров с иерархией
contours, hierarchy = cv2.findContours(thresh_image, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

# Отображение внешних контуров (игнорирование вложенных)
for i, contour in enumerate(contours):
    if hierarchy[0][i][3] == -1:  # Проверка, что контур не имеет родительского контурa
        cv2.drawContours(image, contours, i, (0, 255, 0), 3)

# Отображение изображения с контуром
cv2.imshow('Contours with Hierarchy

', image)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

**Пояснение**:
- Мы ищем контуры с полным набором иерархии, используя **`cv2.RETR_TREE`**.
- Иерархия контуров хранится в массиве, где для каждого контура указывается его связь с родительскими и дочерними контурами.
- В примере мы рисуем только те контуры, которые не имеют вложенных объектов, проверяя условие, что **`hierarchy[0][i][3] == -1`**. Это означает, что данный контур не является дочерним для других.
