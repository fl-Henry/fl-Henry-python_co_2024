# Занятие 4: Введение в Pandas: Series и DataFrame
## 1. Введение в Pandas

### Что такое Pandas?
Pandas — это мощная библиотека Python, предназначенная для анализа и манипуляции данными. Основные характеристики Pandas:

- **Структуры данных**: Pandas предоставляет две основные структуры данных — Series и DataFrame. Series — это одномерный массив, а DataFrame — двумерная таблица, аналогичная таблице в Excel или SQL.

- **Гибкость и удобство**: Pandas позволяет легко обрабатывать данные, используя мощные функции для фильтрации, агрегации и преобразования данных. Библиотека идеально подходит для работы с "грязными" данными, которые требуют предварительной обработки.

- **Интеграция с другими библиотеками**: Pandas хорошо интегрируется с другими библиотеками Python, такими как NumPy (для числовых вычислений), Matplotlib и Seaborn (для визуализации данных), что делает его незаменимым инструментом в области науки о данных.

### Установка и импорт библиотеки
Перед тем как начать использовать Pandas, необходимо установить его. Обычно это делается с помощью менеджера пакетов pip. Если у вас уже установлен Python, выполните следующую команду в терминале:

```bash
pip install pandas
```

Это действие загрузит и установит последнюю версию Pandas и его зависимости.

После установки библиотеки, ее необходимо импортировать в ваш проект. Это делается с помощью команды:

```python
import pandas as pd
```

Здесь `pd` — это сокращение, которое используется для упрощения обращения к функциям библиотеки. Такой подход делает код более читаемым и удобным. Теперь вы можете использовать все возможности Pandas, обращаясь к ним через префикс `pd`.

### Примечание
Важно помнить, что Pandas требует наличия Python версии 3.6 или выше. Убедитесь, что у вас установлена подходящая версия. Для проверки текущей версии Python введите команду:

```bash
python --version
```

## 2. Series

### Определение и создание Series

**Series** в Pandas — это одномерная структура данных, которая может хранить данные различных типов (например, целые числа, числа с плавающей запятой, строки и т.д.). Каждый элемент Series ассоциирован с индексом, что позволяет удобно обращаться к данным и выполнять манипуляции.

#### Основные характеристики Series:
- **Одномерность**: Series представляет собой однонаправленный массив данных.
- **Индексы**: Каждый элемент имеет уникальный индекс, который по умолчанию начинается с 0, но может быть задан пользователем.
- **Гибкость типов данных**: Series может содержать данные разных типов, что делает его универсальным для анализа данных.

#### Создание Series
Существует несколько способов создания Series в Pandas:

1. **Создание Series из списка**:
   ```python
   import pandas as pd

   data = [10, 20, 30, 40]
   series = pd.Series(data)
   ```
   *В этом примере мы создаем Series из списка целых чисел. Индексы будут автоматически присвоены от 0 до 3.*

2. **Создание Series с заданными индексами**:
   ```python
   data = [10, 20, 30, 40]
   index = ['a', 'b', 'c', 'd']
   series = pd.Series(data, index=index)
   ```
   *Теперь мы создали Series, где каждый элемент имеет пользовательский индекс. Это позволяет легче ориентироваться в данных и обращаться к ним по понятным меткам.*

3. **Создание Series из словаря**:
   ```python
   data = {'a': 10, 'b': 20, 'c': 30}
   series = pd.Series(data)
   ```
   *При создании Series из словаря ключи становятся индексами, а значения — элементами Series. Это особенно удобно для создания структурированных данных.*

4. **Создание Series из NumPy массива**:
   ```python
   import numpy as np

   data = np.array([10, 20, 30, 40])
   series = pd.Series(data)
   ```
   *Вы можете создать Series на основе массива NumPy, что позволяет использовать преимущества обеих библиотек.*

5. **Создание пустой Series**:
   ```python
   series = pd.Series()
   ```
   *Это создаст пустую Series, которую вы сможете заполнить данными позже.*

### Примечания
- **Тип индекса**: Индекс может быть не только числовым, но и строковым, что помогает в организации данных и улучшает их читаемость.
- **Обратите внимание на производительность**: Series оптимизирована для быстрого доступа и манипуляции данными, что делает ее подходящей для обработки больших объемов информации.

### Индексация и выбор данных в Series

Индексация в Series — это один из ключевых аспектов, который позволяет эффективно работать с данными. Pandas предоставляет несколько способов доступа к элементам, что делает процесс интуитивно понятным и удобным.

#### 1. Индексация по позиции
Индексация по позиции позволяет обращаться к элементам Series, используя их числовые индексы (начиная с 0).

```python
import pandas as pd

data = [10, 20, 30, 40]
series = pd.Series(data)

# Доступ к элементу по позиции
element = series[1]  # Вернет 20
```
*Здесь мы обращаемся к элементу с индексом 1, получая значение 20.*

#### 2. Индексация по метке
Вы можете также использовать метки индекса для доступа к элементам. Это особенно полезно, когда индексы не являются числовыми.

```python
data = [10, 20, 30, 40]
index = ['a', 'b', 'c', 'd']
series = pd.Series(data, index=index)

# Доступ по метке
element = series['b']  # Вернет 20
```
*В данном примере мы используем метку 'b', чтобы получить соответствующее значение.*

#### 3. Срезы
Срезы позволяют выбирать несколько элементов сразу, что упрощает работу с подмножествами данных.

```python
# Срез от 1 до 3
subset = series[1:3]  # Вернет b    20
                      #          c    30
```
*Срез возвращает элементы с индексами 1 и 2 (включительно), что позволяет легко получать подмножество данных.*

#### 4. Логическая индексация
Логическая индексация позволяет выбирать элементы на основе условий. Это мощный инструмент для фильтрации данных.

```python
# Логическая индексация
filtered_series = series[series > 20]  # Вернет c    30
                                         #          d    40
```
*В этом примере мы выбираем элементы, которые больше 20. Результат — новая Series с отфильтрованными данными.*

#### 5. Индексация с использованием метода `.loc` и `.iloc`
- **`.loc`** используется для доступа к данным по меткам индекса.
- **`.iloc`** — для доступа по позициям.

```python
# Использование .loc
element = series.loc['b']  # Вернет 20

# Использование .iloc
element = series.iloc[1]   # Вернет 20
```
*Оба метода обеспечивают дополнительную гибкость, особенно при работе с большими наборами данных.*


### Операции с Series (арифметические, логические)

Series в Pandas поддерживает множество операций, что делает ее мощным инструментом для анализа данных. Эти операции можно разделить на арифметические и логические.

#### 1. Арифметические операции
Арифметические операции позволяют выполнять вычисления между элементами Series, а также между Series и скалярными значениями.

##### 1.1. Операции с двумя Series
Когда вы выполняете арифметические операции между двумя Series, элементы с одинаковыми индексами суммируются (или вычитаются и т.д.).

```python
import pandas as pd

data1 = [10, 20, 30]
data2 = [1, 2, 3]
index = ['a', 'b', 'c']

series1 = pd.Series(data1, index=index)
series2 = pd.Series(data2, index=index)

# Сложение двух Series
result = series1 + series2
print(result)
```
*Вывод будет:*
```
a    11
b    22
c    33
dtype: int64
```
*Каждое значение series1 увеличивается на соответствующее значение series2.*

##### 1.2. Операции со скалярными значениями
Вы также можете выполнять операции со скалярными значениями. Они будут применяться ко всем элементам Series.

```python
# Умножение на скаляр
result = series1 * 2
print(result)
```
*Вывод будет:*
```
a    20
b    40
c    60
dtype: int64
```
*Каждое значение умножается на 2.*

#### 2. Логические операции
Логические операции позволяют выполнять сравнения и фильтрацию данных. Результатом таких операций будет новая Series с логическими значениями (`True` или `False`).

##### 2.1. Сравнения
Вы можете сравнивать элементы Series с числовыми значениями или друг с другом.

```python
# Сравнение
greater_than_15 = series1 > 15
print(greater_than_15)
```
*Вывод будет:*
```
a    False
b     True
c     True
dtype: bool
```
*Результат показывает, какие элементы больше 15.*

##### 2.2. Комбинированные условия
Можно также использовать несколько условий одновременно, применяя логические операторы (`&`, `|`, `~`).

```python
# Комбинированные условия
filtered = series1[(series1 > 15) & (series1 < 30)]
print(filtered)
```
*Вывод будет:*
```
b    20
dtype: int64
```
*Здесь мы отфильтровали элементы, которые больше 15 и меньше 30.*

#### 3. Уникальные функции
Кроме стандартных арифметических и логических операций, Pandas предлагает множество встроенных функций для работы с Series:

- **Сумма**: `series.sum()`
- **Среднее**: `series.mean()`
- **Минимум**: `series.min()`
- **Максимум**: `series.max()`

```python
# Пример использования функций
print(series1.sum())   # Сумма всех элементов
print(series1.mean())  # Среднее значение
```

### Применение функций к Series

Функции в Pandas позволяют эффективно обрабатывать и анализировать данные в Series. Существует несколько способов применения функций, которые помогают выполнять вычисления, трансформации и агрегацию данных.

#### 1. Встроенные функции
Pandas предоставляет множество встроенных функций для выполнения различных операций над Series. Эти функции можно применять непосредственно к объекту Series.

##### 1.1. Статистические функции
Среди самых распространенных встроенных функций можно выделить:

- **Сумма**: возвращает сумму всех значений в Series.
  ```python
  total = series.sum()
  ```

- **Среднее значение**: вычисляет среднее арифметическое.
  ```python
  mean_value = series.mean()
  ```

- **Минимум и максимум**: находят минимальное и максимальное значение соответственно.
  ```python
  min_value = series.min()
  max_value = series.max()
  ```

##### 1.2. Подсчет уникальных значений
Функция `unique()` позволяет получить массив уникальных значений из Series.

```python
unique_values = series.unique()
```
*Это полезно для анализа распределения данных и выявления уникальных категорий.*

##### 1.3. Частота значений
Функция `value_counts()` возвращает количество вхождений каждого уникального значения в Series.

```python
counts = series.value_counts()
```
*Это позволяет быстро понять, как часто встречаются определенные элементы.*

#### 2. Применение пользовательских функций
Вы можете применять свои собственные функции к каждому элементу Series с помощью методов `apply()` и `map()`.

##### 2.1. Метод `apply()`
Метод `apply()` позволяет применять функцию к каждому элементу Series.

```python
def square(x):
    return x ** 2

squared_series = series.apply(square)
```
*Здесь мы создаем новую Series, в которой каждый элемент возведен в квадрат.*

##### 2.2. Метод `map()`
Метод `map()` работает аналогично, но чаще используется для преобразования данных.

```python
mapped_series = series.map(lambda x: x * 10)
```
*В этом примере мы умножаем каждое значение Series на 10, создавая новую Series с преобразованными данными.*

#### 3. Использование функции `transform()`
Метод `transform()` позволяет применять функции к группам данных в Series. Это полезно при работе с агрегированными данными.

```python
grouped_series = series.groupby(['a', 'b']).transform('mean')
```
*Это применит функцию среднего значения к каждому элементу в группах, что позволяет получать результаты для каждой группы без изменения структуры данных.*

## 3. DataFrame

**DataFrame** — это двумерная структура данных в Pandas, которая позволяет хранить данные в виде таблицы, аналогичной таблице в Excel или SQL. Каждый столбец DataFrame может содержать данные различных типов (например, числовые, строковые, булевы и т.д.). DataFrame обладает следующими ключевыми характеристиками:

- **Строки и столбцы**: Каждая строка и каждый столбец имеют свои индексы, что позволяет удобно обращаться к данным.
- **Гибкость**: DataFrame может содержать данные различной формы и размера, что делает его универсальным инструментом для анализа данных.

### Создание DataFrame

Существует несколько способов создания DataFrame, каждый из которых подходит для различных ситуаций и типов данных.

#### 1. Создание DataFrame из словаря

Словарь в Python может служить отличным источником для создания DataFrame. Ключи словаря становятся названиями столбцов, а значения — данными в этих столбцах.

```python
import pandas as pd

data = {
    'name': ['Alice', 'Bob', 'Charlie'],
    'age': [25, 30, 35],
    'city': ['New York', 'Los Angeles', 'Chicago']
}

df = pd.DataFrame(data)
```

*В этом примере мы создаем DataFrame с тремя столбцами: `name`, `age` и `city`. Каждая строка соответствует одной записи, а значения в списках — это данные для этих записей.*

#### 2. Создание DataFrame из списка списков

Вы также можете создать DataFrame, используя список списков, где каждый внутренний список представляет собой строку.

```python
data = [
    ['Alice', 25, 'New York'],
    ['Bob', 30, 'Los Angeles'],
    ['Charlie', 35, 'Chicago']
]

df = pd.DataFrame(data, columns=['name', 'age', 'city'])
```

*Здесь мы явно указываем названия столбцов с помощью параметра `columns`, что делает структуру данных более понятной.*

#### 3. Создание DataFrame из NumPy массива

Если у вас уже есть данные в виде массива NumPy, вы можете легко преобразовать его в DataFrame.

```python
import numpy as np

data = np.array([
    ['Alice', 25, 'New York'],
    ['Bob', 30, 'Los Angeles'],
    ['Charlie', 35, 'Chicago']
])

df = pd.DataFrame(data, columns=['name', 'age', 'city'])
```

*Это позволяет интегрировать функционал NumPy и Pandas, что особенно полезно при работе с большими объемами данных.*

#### 4. Создание DataFrame из CSV файла

Пandas позволяет также загружать данные непосредственно из CSV файлов с помощью метода `pd.read_csv()`.

```python
df = pd.read_csv('data.csv')
```

*Это самый распространенный способ загрузки данных для анализа, так как CSV файлы часто используются для хранения табличных данных.*

#### 5. Создание пустого DataFrame

Иногда может возникнуть необходимость создать пустой DataFrame, который позже можно заполнить данными.

```python
df = pd.DataFrame(columns=['name', 'age', 'city'])
```

*Этот метод позволяет вам заранее определить структуру DataFrame, что полезно при построении данных динамически.*



### Индексация строк и столбцов
Индексация в DataFrame осуществляется с помощью строковых и числовых индексов, что обеспечивает удобный доступ к данным.

### Индексация строк и столбцов в DataFrame

Индексация в DataFrame является важной частью работы с данными, поскольку она позволяет эффективно получать доступ к строкам и столбцам, а также манипулировать ими. Pandas предоставляет различные методы индексации, включая доступ по меткам и позициям.

#### 1. Индексация по строкам

##### 1.1. Индексация по меткам с помощью `.loc[]`

Метод `.loc[]` используется для доступа к строкам по их меткам индекса. Это особенно полезно, когда индексы не являются числовыми.

```python
import pandas as pd

data = {
    'name': ['Alice', 'Bob', 'Charlie'],
    'age': [25, 30, 35],
    'city': ['New York', 'Los Angeles', 'Chicago']
}

df = pd.DataFrame(data)

# Индексация по метке
row = df.loc[0]  # Вернет первую строку
```
*В данном примере мы получаем первую строку DataFrame, где `0` — это метка индекса.*

##### 1.2. Индексация по позициям с помощью `.iloc[]`

Метод `.iloc[]` позволяет обращаться к строкам по числовым позициям, что бывает удобно, когда вам известны индексы.

```python
# Индексация по позиции
row = df.iloc[1]  # Вернет вторую строку (Bob)
```
*Здесь `1` указывает на вторую строку DataFrame.*

#### 2. Индексация по столбцам

Доступ к столбцам DataFrame также можно получать различными способами:

##### 2.1. Доступ по имени столбца

Вы можете получить доступ к столбцу, указав его название в квадратных скобках.

```python
ages = df['age']  # Вернет Series с возрастами
```
*Это возвращает Series, содержащую все значения из столбца `age`.*

##### 2.2. Доступ к нескольким столбцам

Если вам нужно выбрать несколько столбцов, передайте список названий столбцов.

```python
subset = df[['name', 'city']]  # Вернет DataFrame с выбранными столбцами
```
*Это позволяет создавать новые DataFrame с подмножеством данных, что удобно для анализа.*

#### 3. Индексация с использованием срезов

С помощью индексации можно также использовать срезы для получения подмножеств строк или столбцов.

```python
# Получение первых двух строк
subset = df[0:2]  # Вернет первые две строки (Alice и Bob)
```
*Срез `0:2` возвращает строки с индексами 0 и 1, но не включает строку с индексом 2.*

#### 4. Логическая индексация

Логическая индексация позволяет выбирать строки на основе условий.

```python
# Фильтрация по условию
filtered_df = df[df['age'] > 25]  # Вернет строки, где возраст больше 25
```
*Эта операция возвращает новый DataFrame с отфильтрованными данными, соответствующими заданному условию.*

#### 5. Использование метода `.at[]` и `.iat[]`

- **`.at[]`**: используется для быстрого доступа к отдельным элементам по меткам.
- **`.iat[]`**: используется для быстрого доступа к отдельным элементам по позициям.

```python
# Доступ по меткам
age_of_bob = df.at[1, 'age']  # Вернет 30

# Доступ по позициям
age_of_charlie = df.iat[2, 1]  # Вернет 35
```
*Эти методы удобны для получения отдельных значений без необходимости возвращать целые строки или столбцы.*

### Выбор и фильтрация данных
Фильтрация данных в DataFrame позволяет выбирать подмножества строк на основе условий.

#### 1. Фильтрация по условиям
```python
# Фильтрация по условию
filtered_df = df[df['age'] > 30]  # Вернет строки, где возраст больше 30
```
*Эта операция возвращает новый DataFrame с отфильтрованными данными.*

#### 2. Использование логических операций
Вы можете комбинировать несколько условий.

```python
# Комбинированная фильтрация
filtered_df = df[(df['age'] > 25) & (df['city'] == 'Chicago')]
```
*Здесь мы выбираем строки, где возраст больше 25 и город — Chicago.*

### Основные методы DataFrame

DataFrame в Pandas предоставляет множество методов, которые облегчают работу с данными, позволяя получать информацию о структуре, статистике и содержимом. Вот некоторые из самых полезных методов.

#### 1. `info()`

Метод `info()` предоставляет краткий обзор DataFrame, включая информацию о типах данных, количестве ненулевых значений и использовании памяти. Это полезно для первичной оценки структуры данных.

```python
df.info()
```
*Вывод включает следующие данные:*
- Количество строк и столбцов
- Названия столбцов и их типы
- Количество ненулевых значений в каждом столбце
- Использование памяти

#### 2. `describe()`

Метод `describe()` выводит статистическую информацию о числовых столбцах, включая:
- Количество значений
- Среднее
- Стандартное отклонение
- Минимум и максимум
- Квартильные значения

```python
df.describe()
```
*Этот метод полезен для понимания распределения данных и выявления аномалий.*

#### 3. `head()`

Метод `head()` возвращает первые несколько строк DataFrame (по умолчанию 5), что позволяет быстро оценить содержимое.

```python
df.head()  # Вернет первые 5 строк
```
*Вы можете указать количество строк, например, `df.head(10)` вернет первые 10 строк.*

#### 4. `tail()`

Метод `tail()` работает аналогично `head()`, но возвращает последние несколько строк DataFrame.

```python
df.tail()  # Вернет последние 5 строк
```
*Это полезно для быстрого просмотра конечной части набора данных.*

#### 5. `value_counts()`

Метод `value_counts()` позволяет подсчитать количество уникальных значений в столбце. Это полезно для анализа категориальных данных.

```python
df['city'].value_counts()
```
*Вывод покажет количество вхождений каждого уникального города в столбце `city`.*

#### 6. `sort_values()`

Метод `sort_values()` позволяет сортировать DataFrame по значениям в указанном столбце.

```python
df_sorted = df.sort_values(by='age', ascending=False)  # Сортировка по возрасту по убыванию
```
*Это удобно для анализа данных, например, для нахождения самых старших или младших записей.*

#### 7. `groupby()`

Метод `groupby()` используется для агрегации данных по категориям. Это позволяет разделять данные на группы и применять агрегирующие функции.

```python
grouped = df.groupby('city').mean()  # Средний возраст по городам
```
*Здесь мы получаем средний возраст для каждой группы городов.*

#### 8. `apply()`

Метод `apply()` позволяет применять функции к строкам или столбцам DataFrame. Это полезно для выполнения более сложных преобразований.

```python
# Применение функции к столбцу
df['age_squared'] = df['age'].apply(lambda x: x ** 2)  # Возводим возраст в квадрат
```

