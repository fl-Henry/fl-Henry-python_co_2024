# Занятие 8: Работа с индексами

## 1. **Типы индексов в Pandas**

В Pandas индекс играет ключевую роль в организации и доступе к данным. Он может быть как автоматически сгенерированным, так и настроенным вручную, что дает гибкость в работе с данными. 

### **Автоматически создаваемые индексы в Pandas**

Когда вы создаёте **DataFrame** из данных без явного указания индекса, Pandas автоматически создаёт **инекс по умолчанию**. Этот индекс представляет собой просто **целочисленную последовательность** от 0 до N-1, где N — это количество строк в DataFrame. Такой индекс автоматически устанавливается, если не указан другой.

```python
import pandas as pd

# Создание DataFrame без указания индекса
data = {'A': [1, 2, 3], 'B': [4, 5, 6]}
df = pd.DataFrame(data)

# Просмотр DataFrame
print(df)
```

**Результат**:

```
   A  B
0  1  4
1  2  5
2  3  6
```

Здесь индексы автоматически сгенерированы как 0, 1, 2. Этот индекс подходит, если ваши данные не требуют специфической индексации и могут быть обработаны как последовательность.


### **Установка собственного индекса при создании DataFrame**

Если вы хотите использовать **собственный индекс**, можно передать список или массив значений в параметр `index` при создании DataFrame. Это позволяет задать осмысленные метки для строк, что может быть полезно для удобной индексации и фильтрации данных.

```python
# Создание DataFrame с пользовательским индексом
data = {'A': [1, 2, 3], 'B': [4, 5, 6]}
index = ['row1', 'row2', 'row3']
df = pd.DataFrame(data, index=index)

# Просмотр DataFrame с пользовательским индексом
print(df)
```

**Результат**:

```
       A  B
row1  1  4
row2  2  5
row3  3  6
```

Теперь строки имеют осмысленные метки (`row1`, `row2`, `row3`), что позволяет легче манипулировать данными и обращаться к ним по меткам, а не по числовым индексам.

**Пояснение**:  
Когда вы задаете собственный индекс, вы получаете больший контроль над тем, как будет осуществляться доступ к данным. Это особенно полезно, если индексы должны отражать какой-то контекст или семантику (например, дату или уникальный идентификатор).


### **Многоуровневые индексы (MultiIndex)**

Многоуровневый индекс (или `MultiIndex`) позволяет задавать **индексы с несколькими уровнями**. Это особенно полезно для работы с **многомерными данными**, например, когда ваши данные имеют структуру с несколькими атрибутами (например, дата и страна). Многоуровневые индексы позволяют эффективно агрегировать данные и выполнять более сложные операции индексации.

##### **Создание многоуровневого индекса**

Многоуровневый индекс можно создать как при помощи передачи списка кортежей в индекс, так и с использованием специальных функций `pd.MultiIndex.from_product()` или `pd.MultiIndex.from_tuples()`.

```python
import pandas as pd

# Создание многоуровневого индекса с использованием списка кортежей
arrays = [['A', 'A', 'B', 'B'], [1, 2, 1, 2]]
index = pd.MultiIndex.from_arrays(arrays, names=('letter', 'number'))

data = {'value': [10, 20, 30, 40]}
df = pd.DataFrame(data, index=index)

# Просмотр DataFrame с многоуровневым индексом
print(df)
```

**Результат**:

```
               value
letter number       
A      1          10
       2          20
B      1          30
       2          40
```

**Пояснение**:  
Здесь используется двухуровневый индекс, состоящий из двух компонентов: `letter` и `number`. Это позволяет эффективно группировать данные по нескольким признакам одновременно. Например, можно выполнить агрегацию данных по одному из уровней индекса, или выполнить выборку по нескольким уровням.

## 2. **Создание и изменение индексов в Pandas**

В Pandas работа с индексами предоставляет мощные инструменты для эффективной организации данных и выполнения операций. Иногда важно **изменить индекс** в DataFrame, чтобы обеспечить удобный доступ к данным или улучшить производительность.

### **Установка индекса с помощью метода `.set_index()`**

Метод **`.set_index()`** позволяет преобразовать один или несколько столбцов DataFrame в индекс. Это полезно, когда столбцы содержат уникальные или важные данные, которые должны служить метками строк в DataFrame.

#### **Преобразование столбцов в индексы**

Когда вам нужно установить один столбец в качестве индекса, вы можете сделать это с помощью метода `.set_index()`. Столбец, который вы хотите использовать в качестве индекса, будет удалён из данных и станет частью структуры индекса.

```python
import pandas as pd

# Пример данных
data = {'ID': [1, 2, 3], 'Name': ['Alice', 'Bob', 'Charlie'], 'Age': [25, 30, 35]}
df = pd.DataFrame(data)

# Установка столбца 'ID' как индекс
df_with_index = df.set_index('ID')

print(df_with_index)
```

**Результат**:

```
       Name  Age
ID              
1     Alice   25
2       Bob   30
3   Charlie   35
```

**Пояснение**:
- Столбец **'ID'** стал индексом DataFrame.
- Этот метод **удаляет столбец** из данных, превращая его в индекс. Если вы хотите сохранить столбец в данных, можно использовать параметр `drop=False`.

#### **Указание нескольких столбцов в качестве индекса**

С помощью метода `.set_index()` можно одновременно указать несколько столбцов в качестве индекса. Это полезно, когда вы хотите создать сложную структуру индекса (например, для многомерных данных).

```python
# Установка нескольких столбцов как индекса
df_multi_index = df.set_index(['Name', 'Age'])

print(df_multi_index)
```

**Результат**:

```
               ID
Name    Age      
Alice   25     1
Bob     30     2
Charlie 35     3
```

**Пояснение**:
- Теперь DataFrame использует **многоуровневый индекс** (`Name`, `Age`), что позволяет более гибко работать с данными.
- Многоуровневые индексы полезны, когда данные имеют несколько категорий или факторов, которые нужно учитывать одновременно.


### **Сброс индекса с помощью метода `.reset_index()`**

Метод **`.reset_index()`** используется для **восстановления стандартного числового индекса** (от 0 до N-1), если вы уже использовали `set_index()` и хотите вернуться к изначальной структуре данных.

Когда вы применяете `.reset_index()`, индексы DataFrame сбрасываются, и DataFrame получает новый стандартный числовой индекс. При этом индекс становится обычным столбцом.

```python
# Сброс индекса
df_reset = df_with_index.reset_index()

print(df_reset)
```

**Результат**:

```
    ID     Name  Age
0    1    Alice   25
1    2      Bob   30
2    3  Charlie   35
```

**Пояснение**:
- Теперь индекс снова является **целочисленным** (0, 1, 2).
- Столбец, который был ранее индексом (в нашем случае **'ID'**), возвращается в обычный столбец в DataFrame.

**Удаление индекса и преобразование его в обычный столбец**

Если вы хотите удалить индекс и при этом сохранить его как обычный столбец, можно использовать параметр **`drop=False`** в методе `.reset_index()`.

```python
# Сброс индекса без удаления его из DataFrame
df_reset_drop_false = df_with_index.reset_index(drop=False)

print(df_reset_drop_false)
```

**Результат**:

```
    ID     Name  Age
0    1    Alice   25
1    2      Bob   30
2    3  Charlie   35
```

**Пояснение**:
- Столбец **'ID'** остаётся в DataFrame после сброса индекса, но теперь он стал обычным столбцом данных.
- Если бы мы использовали **`drop=True`**, индекс был бы полностью удалён, и столбец **'ID'** не вернулся бы в DataFrame.

## 3. **Многоуровневые индексы (MultiIndex) в Pandas**

Многоуровневые индексы (или **`MultiIndex`**) — это мощная возможность в Pandas, позволяющая работать с данными, которые имеют более сложную структуру. Это особенно полезно, когда данные имеют несколько категориальных признаков, и вы хотите организовать их в виде более удобного для анализа и обработки индекса. Многоуровневые индексы позволяют эффективно агрегировать и извлекать информацию из многомерных данных.


### **Создание многоуровневых индексов с помощью `pd.MultiIndex.from_tuples()` или `pd.MultiIndex.from_product()`**

Для создания многоуровневого индекса в Pandas используются методы **`pd.MultiIndex.from_tuples()`** и **`pd.MultiIndex.from_product()`**. Оба этих метода позволяют организовать несколько уровней индекса для DataFrame или Series.

#### **Создание многоуровневого индекса с помощью `pd.MultiIndex.from_tuples()`**

Этот метод позволяет создавать многоуровневый индекс, передавая список кортежей, где каждый кортеж соответствует одному элементу индекса, состоящему из нескольких уровней.

```python
import pandas as pd

# Создание кортежей для индекса
tuples = [('A', 1), ('A', 2), ('B', 1), ('B', 2)]

# Создание многоуровневого индекса
multi_index = pd.MultiIndex.from_tuples(tuples, names=('Letter', 'Number'))

# Создание DataFrame с многоуровневым индексом
data = {'Value': [10, 20, 30, 40]}
df = pd.DataFrame(data, index=multi_index)

print(df)
```

**Результат**:

```
               Value
Letter Number       
A      1          10
       2          20
B      1          30
       2          40
```

**Пояснение**:
- Используя **`pd.MultiIndex.from_tuples()`**, мы создали многоуровневый индекс с двумя уровнями: `Letter` и `Number`.
- Каждый кортеж в списке `tuples` представляет пару значений, которые будут использоваться в соответствующих уровнях индекса.

#### **Создание многоуровневого индекса с помощью `pd.MultiIndex.from_product()`**

Метод **`pd.MultiIndex.from_product()`** позволяет создать индекс, который будет представлять все возможные комбинации значений из двух или более списков (или других итерируемых объектов).

```python
# Создание двух списков для индекса
letters = ['A', 'B']
numbers = [1, 2]

# Создание многоуровневого индекса с помощью `from_product`
multi_index_product = pd.MultiIndex.from_product([letters, numbers], names=('Letter', 'Number'))

# Создание DataFrame с многоуровневым индексом
df_product = pd.DataFrame({'Value': [10, 20, 30, 40]}, index=multi_index_product)

print(df_product)
```

**Результат**:

```
               Value
Letter Number       
A      1          10
       2          20
B      1          30
       2          40
```

**Пояснение**:
- С помощью **`pd.MultiIndex.from_product()`** мы создали многоуровневый индекс, который представляет все возможные комбинации значений из списков `letters` и `numbers`.
- Это полезно, когда вам нужно создать индекс, состоящий из всех возможных сочетаний значений для нескольких категорий.

### **Индексация и выбор данных с многоуровневыми индексами**

Многоуровневый индекс позволяет более гибко извлекать данные. С помощью **`.loc[]`** или **`.iloc[]`** можно легко работать с многомерными индексами.

#### **Доступ к данным по уровням индекса**

Когда в DataFrame установлен многоуровневый индекс, можно обратиться к данным, указав значения для одного или нескольких уровней индекса.

```python
# Доступ к данным для уровня "Letter" равного 'A' и "Number" равного 1
print(df.loc[('A', 1)])

# Результат: 10
```

**Пояснение**:
- Здесь мы используем **`.loc[]`** для получения значения по конкретному сочетанию индексов (`'A'` и `1`).
- Вы также можете обратиться только к одному уровню индекса, например, получить все данные для `'A'`:

```python
# Доступ ко всем данным для 'A'
print(df.loc['A'])
```

**Результат**:

```
         Value
Number        
1          10
2          20
```

#### **Срезы с многоуровневыми индексами**

Можно использовать срезы по одному или нескольким уровням индекса, чтобы извлечь данные по диапазонам значений.

```python
# Доступ ко всем данным с уровня "Letter", равным 'A' или 'B'
print(df.loc['A':'B'])
```

**Результат**:

```
               Value
Letter Number       
A      1          10
       2          20
B      1          30
       2          40
```

**Пояснение**:
- В этом примере используется срез по уровню индекса **`Letter`**, который охватывает все строки от `'A'` до `'B'` включительно.

---

### **Использование `.xs()` для извлечения данных по определенному уровню**

Метод **`.xs()`** (cross-section) используется для извлечения данных по определённому уровню индекса. Это позволяет быстро получать данные по одному из уровней индекса, оставляя остальные уровни неизменными.

```python
# Использование `.xs()` для извлечения данных по уровню 'Number' равному 1
print(df.xs(1, level='Number'))
```

**Результат**:

```
        Value
Letter       
A          10
B          30
```

**Пояснение**:
- Метод **`.xs()`** позволяет извлечь срез по уровню индекса, например, все строки, где `Number = 1`.
- Это удобно, когда вы хотите быстро получить данные, сгруппированные по определённому уровню индекса.

### **Перестановка уровней индекса с помощью `swaplevel()`**

Метод **`swaplevel()`** используется для обмена местами двух уровней индекса в многоуровневом DataFrame. Это может быть полезно, если вы хотите изменить порядок индексов для удобства или для выполнения операций, например, сортировки.

```python
# Перестановка уровней индекса
df_swapped = df.swaplevel()

print(df_swapped)
```

**Результат**:

```
               Value
Number Letter       
1      A          10
2      A          20
1      B          30
2      B          40
```

**Пояснение**:
- Метод **`swaplevel()`** меняет местами уровни индекса. В данном примере, после перестановки, уровень **`Letter`** стал первым, а **`Number`** — вторым.
- Это удобно, когда вам нужно изменить порядок индекса для упрощения операций или визуализации.


### **Сортировка по нескольким уровням индекса**

Когда у вас есть многоуровневый индекс, сортировка по нескольким уровням может быть полезной для группировки и агрегации данных. В Pandas для сортировки по индексам используется метод **`.sort_index()`**.

```python
# Сортировка DataFrame по индексу
df_sorted = df.sort_index()

print(df_sorted)
```

**Результат**:

```
               Value
Letter Number       
A      1          10
       2          20
B      1          30
       2          40
```

**Пояснение**:
- Метод **`.sort_index()`** сортирует DataFrame по индексам. В случае с многоуровневыми индексами, он сортирует по всем уровням, начиная с первого и до последнего.

#### **Сортировка по определённому уровню индекса**

Если вы хотите сортировать только по одному уровню индекса, можно использовать параметр `level`.

```python
# Сортировка только по уровню 'Letter'
df_sorted_letter = df.sort_index(level='Letter')

print(df_sorted_letter)
```

**Результат**:

```
               Value
Letter Number       
A      1          10
       2          20
B      1          30
       2          40
```

**Пояснение**:
- Здесь мы отсортировали DataFrame по уровню индекса **`Letter`**. Если бы у нас было больше уровней, они оставались бы на своих местах.

## 4. **Манипуляции с индексами в Pandas**

Работа с индексами является неотъемлемой частью эффективной работы с данными в Pandas. В этом разделе мы рассмотрим различные методы манипуляций с индексами, которые позволяют упростить организацию, модификацию и слияние данных. Мы коснемся таких операций, как **переименование уровней индекса**, **работа с индексами временных рядов**, **удаление индекса без сохранения в столбце**, а также **объединение DataFrame с разными индексами**.

### **Переименование уровней индекса с помощью `.rename_axis()`**

Метод **`.rename_axis()`** позволяет переименовывать уровни индекса в DataFrame или Series. Это полезно, когда вы хотите сделать ваши данные более читаемыми или улучшить их организацию, особенно если индексы имеют абстрактные имена.

#### **Пример переименования уровней индекса**

```python
import pandas as pd

# Пример с многоуровневым индексом
data = {'Value': [10, 20, 30, 40]}
index = pd.MultiIndex.from_tuples([('A', 1), ('A', 2), ('B', 1), ('B', 2)], names=('Letter', 'Number'))

df = pd.DataFrame(data, index=index)

# Переименование уровней индекса
df = df.rename_axis(columns='Category', index=('New name', 'Number'))

print(df)
```

**Результат**:

```
Category         Value
New name Number       
A        1          10
         2          20
B        1          30
         2          40
```

**Пояснение**:
- В данном примере метод **`.rename_axis()`** переименовал уровень **'Letter'** в **'New name'**, а уровень **'Number'** остался неизменным.
- Этот метод не изменяет данные, а только обновляет имена уровней индекса, что делает DataFrame более читаемым и структурированным.


### **Работа с индексами временных рядов**

Работа с временными рядами является одной из основных задач в анализе данных. Pandas предоставляет множество инструментов для обработки временных данных. Временные индексы (например, `DatetimeIndex`) позволяют выполнять различные операции, такие как агрегация, срезы и выемка данных по времени.

#### **Создание временного индекса**

Пусть у нас есть данные, в которых индексом является временная метка:

```python
# Создание временных данных
dates = pd.date_range('2024-01-01', periods=4, freq='D')
data = {'Temperature': [22, 23, 21, 19]}

df_time = pd.DataFrame(data, index=dates)

print(df_time)
```

**Результат**:

```
            Temperature
2024-01-01           22
2024-01-02           23
2024-01-03           21
2024-01-04           19
```

**Пояснение**:
- Метод **`pd.date_range()`** создает последовательность дат, которую мы затем используем как индекс для DataFrame.
- Временной индекс позволяет легко работать с данными по времени, например, для выполнения срезов.

#### **Срезы по временным индексам**

Срезы по временным индексам позволяют легко извлекать данные в нужном интервале.

```python
# Извлечение данных с 2 января 2024 года
print(df_time['2024-01-02':])
```

**Результат**:

```
            Temperature
2024-01-02           23
2024-01-03           21
2024-01-04           19
```

**Пояснение**:
- Когда индекс является временным, можно использовать строковые метки, чтобы легко выполнить срез по датам.
- В этом примере мы извлекли все данные с 2 января 2024 года по последующие даты.

#### **Преобразования и манипуляции с временными индексами**

Вы также можете выполнять различные операции с временными индексами, например, изменение частоты или агрегацию данных.

```python
# Изменение частоты на месячную и агрегация данных (среднее значение)
df_monthly = df_time.resample('M').mean()

print(df_monthly)
```

**Результат**:

```
            Temperature
2024-01-31           21.25
```

**Пояснение**:
- Использование метода **`resample()`** позволяет изменять частоту временного ряда (например, с дневной на месячную).
- Метод **`mean()`** вычисляет среднее значение температуры за месяц.


### **Объединение DataFrame с разными индексами (concatenation)**

В Pandas вы часто сталкиваетесь с необходимостью объединять данные, которые могут иметь разные индексы. Для этого используется функция **`pd.concat()`**, которая позволяет объединить несколько DataFrame по строкам или столбцам. При этом индексы могут быть как одинаковыми, так и разными.

#### **Пример объединения DataFrame с разными индексами**

```python
# Два DataFrame с разными индексами
df1 = pd.DataFrame({'A': [1, 2]}, index=['a', 'b'])
df2 = pd.DataFrame({'A': [3, 4]}, index=['c', 'd'])

# Объединение DataFrame по строкам
df_concat = pd.concat([df1, df2])

print(df_concat)
```

**Результат**:

```
   A
a  1
b  2
c  3
d  4
```

**Пояснение**:
- Используя **`pd.concat()`**, мы объединили два DataFrame с разными индексами.
- Pandas автоматически выровнял данные по строкам, добавив индексы из обоих DataFrame.

#### **Объединение по столбцам с разными индексами**

```python
# Объединение по столбцам
df_concat_axis1 = pd.concat([df1, df2], axis=1)

print(df_concat_axis1)
```

**Результат**:

```
   A    A
a  1  NaN
b  2  NaN
c  NaN  3
d  NaN  4
```

**Пояснение**:
- При объединении по столбцам с помощью **`axis=1`**, столбцы из разных DataFrame сливаются, но их индексы могут не совпадать. В тех строках, где индексы не совпадают, вставляются значения **NaN**.

#### **Объединение с сохранением ключа**

Если вы хотите добавить столбец, который указывает на источник данных для каждой строки, используйте параметр `keys` в **`pd.concat()`**.

```python
# Объединение с добавлением ключа
df_concat_keys = pd.concat([df1, df2], keys=['First', 'Second'])

print(df_concat_keys)
```

**Результат**:

```
            A
First a  1
      b  2
Second c  3
      d  4
```

**Пояснение**:
- В этом примере добавлен новый уровень индекса, который указывает на источник данных (первый или второй DataFrame).
- Это позволяет более чётко идентифицировать, из какого DataFrame пришли данные.

## 5. Выравнивание и группировка

### **Индексы и группировка данных: использование `.groupby()` с индексами**

Группировка данных с использованием индексов является мощным инструментом для анализа. Метод **`.groupby()`** позволяет группировать данные по значениям индекса или по комбинации столбцов и индексов, после чего можно применять различные агрегации (среднее, сумма, количество и т.д.).

#### **Пример: группировка по индексу**

```python
data = {'Value': [10, 20, 30, 40], 'Category': ['A', 'B', 'A', 'B']}
df = pd.DataFrame(data, index=['a', 'b', 'a', 'c'])

# Группировка по индексу
grouped = df.groupby(df.index).sum()

print(grouped)
```

**Результат**:

```
   Value
a     30
b     60
c     40
```

**Пояснение**:
- В этом примере данные группируются по индексу. Для каждого уникального значения индекса (`'a'`, `'b'`, `'c'`) выполняется агрегация (сумма значений в столбце `Value`).

#### **Пример: группировка по нескольким уровням индекса**

```python
# Многоуровневый индекс
index = pd.MultiIndex.from_tuples([('A', 1), ('A', 2), ('B', 1), ('B', 2)], names=['Letter', 'Number'])
df_multi = pd.DataFrame({'Value': [10, 20, 30, 40]}, index=index)

# Группировка по уровню индекса 'Letter'
grouped_multi = df_multi.groupby('Letter').sum()

print(grouped_multi)
```

**Результат**:

```
        Value
Letter        
A          30
B          70
```

**Пояснение**:
- В этом примере данные группируются по уровню индекса `Letter`. Для каждой группы выполняется суммирование значений в столбце `Value`.

### **Использование `.reindex()` для изменения порядка строк и столбцов**

Метод **`.reindex()`** позволяет изменить порядок строк и столбцов в DataFrame, а также добавить новые индексы или удалить существующие. Это полезно, когда нужно выровнять данные по определенному порядку или индексам.

#### **Пример: изменение порядка строк**

```python
df_reindexed = df.reindex(['b', 'a', 'c'])
print(df_reindexed)
```

**Результат**:

```
   Value Category
b     20        B
a     10        A
c     40        B
```

**Пояснение**:
- Мы использовали **`.reindex()`** для изменения порядка строк в DataFrame. Строки теперь идут в порядке `'b'`, `'a'`, `'c'`.

#### **Добавление новых индексов с `reindex()`**

```python
df_reindexed_new = df.reindex(['a', 'b', 'c', 'd'])
print(df_reindexed_new)
```

**Результат**:

```
   Value Category
a     10        A
b     20        B
c     40        B
d    NaN      NaN
```

**Пояснение**:
- В этом примере мы добавили новый индекс `'d'`, которого не было в исходных данных. Для этого индекса появились значения **NaN**.

### **Применение `.align()` для выравнивания двух DataFrame по индексу**

Метод **`.align()`** используется для выравнивания двух объектов (например, DataFrame или Series) по индексу. Это полезно, когда необходимо совместить данные с разными индексами, автоматически выровняв их и заполнив отсутствующие значения **NaN**.

#### **Пример использования `.align()`**

```python
df1 = pd.DataFrame({'A': [1, 2]}, index=['a', 'b'])
df2 = pd.DataFrame({'B': [3, 4]}, index=['b', 'c'])

# Выравнивание по индексу
df1_aligned, df2_aligned = df1.align(df2, fill_value=0)

print(df1_aligned)
print(df2_aligned)
```

**Результат**:

```
   A  B
a  1  0
b  2  0
c  0  0

   A  B
a  0  0
b  0  3
c  0  4
```

**Пояснение**:
- Метод **`.align()`** выровнял два DataFrame по индексам. Строки с индексами, которых не было в другом DataFrame, были заполнены значениями **NaN** или, в случае использования параметра `fill_value`, заполнены нулями.
