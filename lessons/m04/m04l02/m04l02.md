# Занятие 2: Массивы NumPy: Создание и индексация. Основные операции

## 1. Создание массивов

### Создание массивов из списков
Чтобы начать работу с NumPy, мы можем создать массивы, используя уже существующие списки Python. Это позволяет быстро преобразовать данные в массивы для последующей обработки.

- **Пример:**
  ```python
  import numpy as np
  
  # Создаем список
  list_data = [1, 2, 3, 4, 5]
  
  # Преобразуем его в массив NumPy
  array_data = np.array(list_data)
  print(array_data)  # Вывод: [1 2 3 4 5]
  ```

- **Пояснение:**
  В данном случае `np.array()` принимает список и создает однородный массив, который хранит элементы в виде одного типа данных. Это важно, поскольку NumPy оптимизирует операции над массивами, когда все элементы одного типа.


### Создание многомерных массивов
NumPy также поддерживает создание многомерных массивов, что позволяет организовывать данные в более сложные структуры, такие как матрицы.

- **Пример:**
  ```python
  # Создание двумерного массива из списка списков
  matrix_data = np.array([[1, 2, 3], [4, 5, 6]])
  print(matrix_data)
  ```


### Создание массивов с использованием функций
NumPy предоставляет различные функции для создания массивов, которые позволяют создавать массивы заданного размера или диапазона значений.

- **Функции:**
  - `np.zeros(shape)` — создает массив, заполненный нулями.
  - `np.ones(shape)` — создает массив, заполненный единицами.
  - `np.arange(start, stop, step)` — создает массив чисел в заданном диапазоне.
  - `np.linspace(start, stop, num)` — создает массив с равномерно распределенными числами.

- **Примеры:**
  ```python
  # Массив из нулей
  zeros_array = np.zeros((3, 4))  # 3 строки, 4 столбца
  print(zeros_array)
  
  # Массив из единиц
  ones_array = np.ones((2, 3))
  print(ones_array)
  
  # Массив с диапазоном
  range_array = np.arange(0, 10, 2)
  print(range_array)  # Вывод: [0 2 4 6 8]
  
  # Массив с равномерными числами
  linspace_array = np.linspace(0, 1, 5)
  print(linspace_array)  # Вывод: [0.   0.25 0.5  0.75 1.  ]
  ```

В дополнение к функциям, упомянутым ранее, NumPy предлагает несколько других способов создания массивов:

#### 1. `np.empty(shape)`
- Создает массив заданной формы, но не инициализирует его элементы.
- Элементы массива могут иметь произвольные значения, которые будут находиться в памяти.

**Пример:**
```python
empty_array = np.empty((2, 3))
print(empty_array)
```

#### 2. `np.eye(n)`
- Создает единичную матрицу размером `n*n` (матрица, где на диагонали стоят единицы, а остальные элементы равны нулю).

**Пример:**
```python
identity_matrix = np.eye(3)
print(identity_matrix)
```

#### 3. `np.full(shape, fill_value)`
- Создает массив заданной формы и заполняет его заданным значением.

**Пример:**
```python
full_array = np.full((2, 2), 7)
print(full_array)  # Вывод: [[7 7] [7 7]]
```

#### 4. `np.random.rand(d0, d1, ..., dn)`
- Создает массив с заданной формой и заполняет его случайными числами из равномерного распределения на интервале [0.0, 1.0).

**Пример:**
```python
random_array = np.random.rand(2, 3)  # 2 строки, 3 столбца
print(random_array)
```

#### 5. `np.random.randn(d0, d1, ..., dn)`
- Создает массив с заданной формой и заполняет его случайными числами из стандартного нормального распределения (с средним 0).

**Пример:**
```python
random_normal_array = np.random.randn(2, 3)
print(random_normal_array)
```

#### 6. `np.random.randint(low, high, size)`
- Создает массив заданной формы, заполненный случайными целыми числами в заданном диапазоне [low, high).

**Пример:**
```python
random_int_array = np.random.randint(0, 10, (2, 3))  # 2 строки, 3 столбца
print(random_int_array)
```

## 2. Индексация массивов

Индексация в NumPy позволяет извлекать и модифицировать элементы массивов.

### Основная индексация
Основная индексация позволяет получить доступ к элементам массива по их позициям.

- **Пример:**
  ```python
  import numpy as np

  array = np.array([10, 20, 30, 40, 50])
  print(array[0])  # Вывод: 10
  ```

- **Пояснение:**
  Индексация начинается с нуля, поэтому `array[0]` возвращает первый элемент массива. Также можно использовать отрицательные индексы, чтобы обращаться к элементам с конца массива. Например, `array[-1]` вернет последний элемент.

### Индексация с использованием срезов
Срезы позволяют извлекать подмассивы или подстроки, определяя диапазон индексов.

- **Пример:**
  ```python
  slice_array = array[1:4]  # Извлечение элементов с 1 по 3
  print(slice_array)  # Вывод: [20 30 40]
  ```

- **Пояснение:**
  Синтаксис `start:stop` включает элемент с индексом `start`, но исключает элемент с индексом `stop`. Можно также использовать шаги, например, `array[::2]` вернет каждый второй элемент.

### Множественная индексация
Множественная индексация используется для доступа к элементам многомерных массивов.

- **Пример:**
  ```python
  matrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
  print(matrix[1, 2])  # Вывод: 6
  ```

- **Пояснение:**
  Здесь мы обращаемся к элементу в строке с индексом 1 и столбце с индексом 2. Множественная индексация позволяет работать с двумерными и более высокими массивами, что делает ее особенно полезной для работы с матрицами.

### Обратная индексация
Обратная индексация позволяет получать элементы массива, начиная с конца.

- **Пример:**
  ```python
  print(array[-1])  # Вывод: 50
  print(matrix[-1, -1])  # Вывод: 9
  ```

- **Пояснение:**
  Отрицательные индексы отсчитывают элементы с конца массива, что делает доступ к последним элементам более удобным. Это особенно полезно, когда длина массива неизвестна или может изменяться.

### Сложные примеры индексации
NumPy поддерживает более сложные варианты индексации, включая логическую индексацию и индексацию по массиву индексов.

- **Логическая индексация:**
  Позволяет извлекать элементы на основе условий.
  
  **Пример:**
  ```python
  boolean_mask = array > 30
  print(array[boolean_mask])  # Вывод: [40 50]
  ```

- **Пояснение:**
  Здесь мы создаем маску, которая возвращает элементы, превышающие 30. Это мощный инструмент для фильтрации данных.

- **Индексация по массиву индексов:**
  Позволяет получать элементы, используя массив индексов.

  **Пример:**
  ```python
  indices = [0, 2, 4]
  print(array[indices])  # Вывод: [10 30 50]
  ```

- **Пояснение:**
  Мы можем передать список индексов, чтобы получить сразу несколько элементов массива. Это удобно для выборки данных, когда нужно извлечь элементы по определённым индексам.

## 3. Основные операции с массивами

В NumPy множество встроенных операций, которые позволяют выполнять математические, статистические и логические вычисления над массивами. Эти операции эффективны и оптимизированы для работы с большими объемами данных.

### Арифметические операции
Арифметические операции в NumPy могут выполняться над массивами с помощью стандартных операторов или функций.

- **Примеры:**
  ```python
  import numpy as np

  array1 = np.array([1, 2, 3])
  array2 = np.array([4, 5, 6])

  # Сложение
  sum_array = array1 + array2
  print(sum_array)  # Вывод: [5 7 9]

  # Вычитание
  diff_array = array1 - array2
  print(diff_array)  # Вывод: [-3 -3 -3]

  # Умножение
  prod_array = array1 * array2
  print(prod_array)  # Вывод: [4 10 18]

  # Деление
  div_array = array1 / array2
  print(div_array)  # Вывод: [0.25 0.4  0.5 ]
  ```

- **Пояснение:**
  Все арифметические операции выполняются поэлементно. Это означает, что соответствующие элементы массивов обрабатываются независимо. NumPy автоматически обрабатывает размеры массивов, если они совместимы. Например, если один массив является вектором, а другой — матрицей, операции выполняются корректно.

### Статистические операции
NumPy предоставляет множество функций для вычисления статистических показателей, таких как сумма, среднее значение, стандартное отклонение и т.д.

- **Примеры:**
  ```python
  array = np.array([1, 2, 3, 4, 5])

  # Сумма
  total_sum = np.sum(array)
  print(total_sum)  # Вывод: 15

  # Среднее значение
  mean_value = np.mean(array)
  print(mean_value)  # Вывод: 3.0

  # Стандартное отклонение
  std_deviation = np.std(array)
  print(std_deviation)  # Вывод: 1.4142135623730951

  # Минимум и максимум
  min_value = np.min(array)
  max_value = np.max(array)
  print(min_value, max_value)  # Вывод: 1 5

  # Вычисляет медиану элементов массива.
  median_value = np.median(array)

  # Вычисляет диапазон (разность между максимальным и минимальным значениями).
  range_value = np.ptp(array)

  # Находит уникальные элементы массива и их количество.
  unique_elements, counts = np.unique(array, return_counts=True)
  ```

- **Пояснение:**
  Статистические функции в NumPy работают по всему массиву или вдоль заданной оси. Например, можно найти среднее значение по строкам или столбцам в двумерном массиве. Эти операции полезны для анализа данных и получения сводной информации.

### Операции над элементами (Сравнение, логические операции)
NumPy позволяет выполнять операции сравнения и логические операции, что позволяет создавать маски и фильтры для данных.

- **Примеры:**
  ```python
  array = np.array([1, 2, 3, 4, 5])

  # Сравнение
  greater_than_two = array > 2
  print(greater_than_two)  # Вывод: [False False  True  True  True]

  # Логические операции
  logical_and = (array > 2) & (array < 5)
  print(logical_and)  # Вывод: [False False  True  True False]

  logical_or = (array < 2) | (array > 4)
  print(logical_or)  # Вывод: [ True False False False  True]

  all_true = np.all(array > 0)  # Проверка, все ли элементы больше 0
  any_true = np.any(array < 0)  # Проверка, есть ли хотя бы один элемент меньше 0

  ```

- **Пояснение:**
  Результат операций сравнения — это логический массив, в котором каждый элемент указывает, соответствует ли он заданному условию. Логические операции (`&`, `|`, `~`) могут комбинироваться для создания более сложных условий. Это позволяет легко фильтровать массивы и извлекать нужные данные.

## 4. Формирование новых массивов

Формирование новых массивов в NumPy включает изменение формы, объединение и разделение массивов. Эти операции позволяют эффективно управлять и обрабатывать данные.

### Функции для изменения формы массивов

#### `np.reshape()`
Функция `reshape()` изменяет форму массива, не изменяя его данные. Это полезно, когда нужно изменить представление данных, например, преобразовать одномерный массив в двумерный.

- **Пример:**
  ```python
  array = np.array([1, 2, 3, 4, 5, 6])
  reshaped_array = array.reshape((2, 3))  # Преобразуем в массив 2x3
  print(reshaped_array)
  # Вывод:
  # [[1 2 3]
  #  [4 5 6]]
  ```

- **Пояснение:**
  В этом примере мы изменили одномерный массив в двумерный массив с 2 строками и 3 столбцами. Важно, чтобы общее количество элементов оставалось неизменным: в данном случае 6 элементов. Если размерности не совпадают, NumPy выдаст ошибку.

#### `np.flatten()`
Функция `flatten()` преобразует многомерный массив в одномерный. Это может быть полезно для упрощения работы с данными.

- **Пример:**
  ```python
  matrix = np.array([[1, 2, 3], [4, 5, 6]])
  flat_array = matrix.flatten()
  print(flat_array)  # Вывод: [1 2 3 4 5 6]
  ```

- **Пояснение:**
  Метод `flatten()` создает новый одномерный массив, в который помещаются все элементы исходного массива. Это позволяет легко обрабатывать данные, если они больше не нужны в многомерном виде.

### Объединение и разделение массивов

#### Объединение массивов

**1. `np.concatenate()`**
Функция `concatenate()` объединяет массивы вдоль заданной оси. Это позволяет создавать более крупные массивы из нескольких меньших.

- **Пример:**
  ```python
  array1 = np.array([1, 2, 3])
  array2 = np.array([4, 5, 6])
  combined_array = np.concatenate((array1, array2))
  print(combined_array)  # Вывод: [1 2 3 4 5 6]
  ```

- **Пояснение:**
  В этом примере мы объединили два одномерных массива в один. Функция `concatenate()` принимает кортеж массивов, которые нужно объединить. Можно также указать ось для объединения, если массивы многомерные.

**2. `np.vstack()`**
Функция `vstack()` объединяет массивы по вертикали, т.е. добавляет строки.

- **Пример:**
  ```python
  array1 = np.array([[1, 2, 3]])
  array2 = np.array([[4, 5, 6]])
  stacked_array = np.vstack((array1, array2))
  print(stacked_array)
  # Вывод:
  # [[1 2 3]
  #  [4 5 6]]
  ```

- **Пояснение:**
  Здесь `vstack()` добавляет новую строку к существующему массиву, что удобно для работы с матрицами. Это полезно для агрегации данных.

**3. `np.hstack()`**
Функция `hstack()` объединяет массивы по горизонтали, т.е. добавляет столбцы.

- **Пример:**
  ```python
  array1 = np.array([[1], [2], [3]])
  array2 = np.array([[4], [5], [6]])
  horizontal_stacked_array = np.hstack((array1, array2))
  print(horizontal_stacked_array)
  # Вывод:
  # [[1 4]
  #  [2 5]
  #  [3 6]]
  ```

- **Пояснение:**
  Функция `hstack()` объединяет массивы, добавляя столбцы, что полезно для расширения данных в рамках одного массива.

**4. `np.tile(A, reps)`**
Создает новый массив, который является повторением массива \( A \) указанное количество раз.

**Пример:**
```python
array_to_tile = np.array([[1, 2], [3, 4]])
tiled_array = np.tile(array_to_tile, (2, 3))  # Повторить 2 раза по строкам и 3 раза по столбцам
print(tiled_array)
```

#### Разделение массивов

**1. `np.split()`**
Функция `split()` делит массив на заданное количество частей.

- **Пример:**
  ```python
  array = np.array([1, 2, 3, 4, 5, 6])
  split_arrays = np.split(array, 3)
  print(split_arrays)
  # Вывод: [array([1, 2]), array([3, 4]), array([5, 6])]
  ```

- **Пояснение:**
  Здесь массив был разделен на 3 части. Важно, чтобы размер массива делился на количество частей, иначе NumPy выдаст ошибку. Результатом является список массивов.
