# Занятие 10: Вставка и обновление данных с использованием SQLAlchemy

## 1. Основы вставки данных

Вставка данных — это процесс добавления новых записей в таблицу базы данных. Этот процесс является одной из ключевых операций, позволяющих хранить информацию в реляционных системах управления базами данных (СУБД).

### Различие между вставкой и обновлением
- **Вставка** — это создание новой записи в таблице. Когда мы вставляем данные, мы добавляем новую строку, которая до этого не существовала в базе данных.
- **Обновление** — это изменение существующих данных. Здесь мы выбираем уже существующую запись и изменяем одно или несколько ее полей.

### Типы операций вставки
1. **Одиночная вставка**: добавление одной записи за раз. Эта операция обычно проста и требует меньше ресурсов. Например, в SQL это может выглядеть так:
   ```sql
   INSERT INTO users (name, email) VALUES 
   ('John Doe', 'john@example.com');
   ```
   
2. **Массовая вставка**: добавление нескольких записей за один запрос. Это более эффективный способ, так как снижает количество обращений к базе данных. Например:
   ```sql
   INSERT INTO users (name, email) VALUES 
   ('Alice', 'alice@example.com'), 
   ('Bob', 'bob@example.com');
   ```

## 2. Вставка данных с использованием SQLAlchemy

### 2.1. Вставка одной записи

Вставка одной записи в базу данных с использованием SQLAlchemy включает несколько простых шагов:

1. **Создание объекта модели**: Сначала мы создаем экземпляр модели, которая представляет таблицу в базе данных. Например, если у нас есть модель `User`, мы создаем нового пользователя.

2. **Добавление объекта в сессию**: Мы используем метод `add()`, чтобы добавить созданный объект в сессию. Сессия — это временное хранилище, где мы можем накапливать изменения, прежде чем они будут сохранены в базе данных.

3. **Сохранение изменений**: Наконец, мы вызываем метод `commit()`, чтобы сохранить изменения в базе данных.

**Пример вставки одной записи:**
```python
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from models import User  # Импортируем модель пользователя

# Создаем соединение с базой данных
engine = create_engine('sqlite:///database.db')
Session = sessionmaker(bind=engine)
session = Session()

# Создаем нового пользователя
new_user = User(name='John Doe', email='john@example.com')

# Добавляем пользователя в сессию
session.add(new_user)

# Сохраняем изменения в базе данных
session.commit()
```

**Пояснения:**
- В данном примере мы создаем объект `new_user` с заданными атрибутами.
- Метод `add()` помещает объект в сессию, что позволяет SQLAlchemy отслеживать изменения.
- Вызов `commit()` отправляет все изменения в базу данных, делая их постоянными.

### 2.2. Вставка нескольких записей

Для вставки нескольких записей одновременно можно использовать метод `add_all()`. Это особенно полезно, когда необходимо вставить большое количество данных за один запрос, что снижает нагрузку на базу данных и повышает производительность.

**Пример вставки нескольких записей:**
```python
# Создаем список новых пользователей
new_users = [
    User(name='Alice', email='alice@example.com'),
    User(name='Bob', email='bob@example.com'),
    User(name='Charlie', email='charlie@example.com')
]

# Добавляем всех пользователей в сессию
session.add_all(new_users)

# Сохраняем изменения в базе данных
session.commit()
```

**Пояснения:**
- В этом примере мы создаем список объектов `User` и передаем его методу `add_all()`.
- Этот метод позволяет избежать нескольких вызовов `add()` и делает код более чистым и эффективным.
- После добавления всех объектов в сессию мы снова вызываем `commit()`, чтобы сохранить изменения.

### 2.3. Команда для добавления данных (`add()`, `add_all()`)

#### Метод `add()`
- Используется для вставки одной записи.
- Принимает объект модели и добавляет его в текущую сессию.
- Имеет следующий синтаксис:
  ```python
  session.add(object)
  ```

#### Метод `add_all()`
- Используется для вставки нескольких записей одновременно.
- Принимает список объектов и добавляет их в текущую сессию.
- Позволяет оптимизировать вставку данных, особенно при работе с большими объемами информации.
- Синтаксис:
  ```python
  session.add_all([object1, object2, ...])
  ```

**Пояснения:**
- Оба метода очень удобны для работы с базой данных, так как позволяют эффективно управлять объектами и минимизировать количество обращений к базе данных.
- Использование `add()` и `add_all()` помогает избежать прямого написания SQL-запросов, что упрощает код и делает его более безопасным, так как ORM автоматически обрабатывает экранирование и валидацию данных.

## 3. Обновление данных

### 3.1. Поиск данных для обновления

Прежде чем обновить данные, необходимо их найти. В SQLAlchemy для этого используется сессия и методы фильтрации.

1. **Фильтрация данных**: Мы можем использовать методы `filter()` и `filter_by()` для поиска записей по определенным критериям. Эти методы позволяют задавать условия поиска, аналогичные SQL-запросам.

2. **Получение результата**: После применения фильтрации мы можем использовать метод `first()` для получения первой записи или `all()` для получения всех подходящих записей.

**Пример поиска данных:**
```python
# Поиск пользователя по имени
user = session.query(User).filter_by(name='John Doe').first()
```

**Пояснения:**
- В этом примере мы используем метод `query()` для выполнения выборки из таблицы `User`.
- Метод `filter_by()` задает условие поиска по имени пользователя.
- `first()` возвращает первую найденную запись или `None`, если записи не найдены.

### 3.2. Обновление записей

После того как мы нашли необходимые записи, мы можем их обновить. Обновление в SQLAlchemy также включает несколько простых шагов:

1. **Изменение атрибутов объекта**: Для обновления мы просто изменяем значения атрибутов объекта, который был найден на предыдущем шаге.

2. **Сохранение изменений**: После изменения атрибутов необходимо вызвать `commit()`, чтобы сохранить обновления в базе данных.

**Пример обновления записей:**  
Изменение адреса электронной почты пользователя

```python
# ...
# Подключение к БД и создание сессии
# ...

user = session.query(User).filter_by(name='John Doe').first()
if user:
    user.email = 'john.doe@example.com'  # Обновляем атрибут email
    session.commit()  # Сохраняем изменения
```

**Пояснения:**
- Мы проверяем, был ли найден пользователь. Если он найден, мы обновляем его адрес электронной почты.
- Вызов `commit()` отправляет изменения в базу данных, делая их постоянными.

### 3.3. Примеры обновления данных

#### Пример 1: Обновление одной записи
```python
# Поиск и обновление одного пользователя
user = session.query(User).filter_by(name='Alice').first()
if user:
    user.email = 'alice.new@example.com'
    session.commit()
```

**Пояснения:**
- Мы ищем пользователя по имени "Alice". Если он найден, мы обновляем его email.
- Обновление происходит через изменение атрибута объекта, а затем сохраняется через `commit()`.

#### Пример 2: Массовое обновление
Иногда требуется обновить сразу несколько записей, соответствующих определенному условию. В SQLAlchemy это можно сделать с помощью метода `update()`.

```python
# Массовое обновление всех пользователей с определенным доменом
session.query(User).filter(User.email.like('%@example.com')).update({"email": "updated@example.com"}, synchronize_session=False)
session.commit()
```

**Пояснения:**
- В этом примере мы ищем всех пользователей, чьи адреса электронной почты заканчиваются на `@example.com`.
- Метод `update()` принимает словарь с атрибутами и новыми значениями. Параметр `synchronize_session=False` позволяет избежать необходимости обновления всех объектов в текущей сессии, что может быть полезно для оптимизации производительности.

## 4. Обработка ошибок

Обработка ошибок — важный аспект разработки, который позволяет гарантировать стабильную работу приложения и улучшить пользовательский опыт. 

### 4.1. Исключения при вставке и обновлении

При работе с базами данных могут возникать различные исключения, и важно их обрабатывать, чтобы избежать неожиданных сбоев. Вот некоторые распространенные исключения, с которыми можно столкнуться:

1. **IntegrityError**: Это исключение возникает, когда нарушаются ограничения целостности данных, такие как уникальные ключи или ограничения внешних ключей. Например, попытка вставить запись с уже существующим уникальным идентификатором приведет к этому исключению.
   
   **Пример:**
   ```python
   from sqlalchemy.exc import IntegrityError

   try:
       session.add(new_user)
       session.commit()
   except IntegrityError:
       session.rollback()  # Откатываем изменения в случае ошибки
       print("Ошибка: Пользователь с таким email уже существует.")
   ```

2. **OperationalError**: Это исключение может произойти при проблемах с подключением к базе данных, например, если база данных недоступна или происходит тайм-аут соединения.

3. **DataError**: Возникает, если данные не соответствуют формату, ожидаемому базой данных. Например, попытка вставить строку в столбец, ожидающий целое число.

4. **SQLAlchemyError**: Это базовый класс для всех исключений SQLAlchemy. Его можно использовать для перехвата всех ошибок, связанных с SQLAlchemy.

### 4.2. Использование блоков try-except

Блоки `try-except` позволяют обрабатывать исключения, возникающие в блоке `try`, и выполнять определенные действия в случае их возникновения. Это помогает избежать аварийного завершения приложения и дает возможность реагировать на ошибки.

**Структура блока try-except:**
```python
try:
    # Код, который может вызвать исключение
except SomeException:
    # Код для обработки исключения
```

**Пример обработки ошибок при вставке:**
```python
from sqlalchemy.exc import IntegrityError, SQLAlchemyError

try:
    # Попытка вставить нового пользователя
    new_user = User(name='John Doe', email='john@example.com')
    session.add(new_user)
    session.commit()  # Сохраняем изменения
except IntegrityError:
    session.rollback()  # Откат изменений
    print("Ошибка: Пользователь с таким email уже существует.")
except SQLAlchemyError as e:
    session.rollback()  # Откат изменений
    print(f"Ошибка при работе с базой данных: {e}")
```

**Пояснения:**
- Внутри блока `try` мы пытаемся добавить нового пользователя и сохранить изменения. Если возникает исключение `IntegrityError`, мы откатываем изменения и информируем пользователя об ошибке.
- Если возникает другая ошибка, например, `OperationalError`, мы перехватываем ее с помощью `SQLAlchemyError` и выводим соответствующее сообщение.
