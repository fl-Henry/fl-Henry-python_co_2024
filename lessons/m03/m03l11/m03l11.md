# Занятие 11: Извлечение данных с использованием SQLAlchemy

## 1. Извлечение данных

Извлечение данных из базы данных — это один из основных функционалов SQLAlchemy. 

### Основные операции извлечения

#### `query()`
Метод `query()` является основным способом создания запросов в SQLAlchemy. Он позволяет вам определять, какие объекты вы хотите извлечь из базы данных. 

- **Синтаксис**: `session.query(ModelClass)`
- **Пример**: Чтобы извлечь все записи из таблицы `User`, вы можете написать:
  ```python
  users = session.query(User).all()
  ```
- **Пояснение**: Здесь `session` — это объект сессии, который управляет взаимодействием с базой данных, а `User` — это класс модели, который соответствует таблице в базе данных. Метод `all()` возвращает список всех объектов `User`.

#### `filter()`
Метод `filter()` используется для добавления условий к запросам. Он позволяет отбирать только те записи, которые соответствуют заданным критериям.

- **Синтаксис**: `query().filter(condition)`
- **Пример**: Если вы хотите извлечь пользователей с именем "Alice":
  ```python
  alice_users = session.query(User).filter(User.name == 'Alice').all()
  ```
- **Пояснение**: В данном случае мы используем условие `User.name == 'Alice'`, чтобы отфильтровать только тех пользователей, у которых имя "Alice". 

#### `all()`, `first()`, `get()`
Эти методы используются для получения результатов из запроса:

- **`all()`**: возвращает список всех результатов. Если запрос возвращает несколько записей, они будут представлены в виде списка.
- **`first()`**: возвращает первую запись или `None`, если результатов нет. Это удобно, когда вам нужно получить только один объект.
  ```python
  first_user = session.query(User).first()
  ```
- **`get()`**: используется для получения записи по первичному ключу. Например, если у вас есть ID пользователя, вы можете получить его следующим образом:
  ```python
  user = session.query(User).get(1)
  ```
- **Пояснение**: Метод `get()` оптимизирован для быстрого извлечения объектов по первичному ключу, в то время как `filter()` и `first()` могут использоваться для более сложных условий.


## 2. Продвинутые запросы

Продвинутые запросы в SQLAlchemy позволяют осуществлять более сложные операции с данными, включая объединение таблиц, группировку результатов и сортировку. Эти возможности расширяют функциональность простых запросов и дают возможность более эффективно работать с данными.

### Использование `join()`

Метод `join()` позволяет объединять данные из разных таблиц, основываясь на отношениях между ними. Это особенно полезно, когда вы хотите извлечь информацию из связанных моделей.

- **Синтаксис**: `session.query(ModelA).join(ModelB)`
- **Пример**: Предположим, у вас есть две модели: `User` и `Post`, где каждый пользователь может иметь несколько постов. Чтобы получить пользователей вместе с их постами, вы можете написать:
  ```python
  results = session.query(User).join(Post).all()
  ```
- **Пояснение**: Этот запрос извлекает всех пользователей, которые имеют хотя бы один пост. При этом создается INNER JOIN между таблицами `User` и `Post`. Если вы хотите получить пользователей даже без постов, можно использовать `outerjoin()`.

### Группировка и агрегация

Группировка данных позволяет объединять записи на основе определенных полей, а агрегация — вычислять статистические показатели, такие как сумма, среднее значение и т.д.

- **Синтаксис**: `session.query(func.count(), Model.field).group_by(Model.field)`
- **Пример**: Чтобы узнать, сколько постов у каждого пользователя, можно сделать так:
  ```python
  from sqlalchemy import func

  results = session.query(User, func.count(Post.id)).join(Post).group_by(User.id).all()
  ```
- **Пояснение**: В этом запросе мы используем `func.count()` для подсчета количества постов для каждого пользователя. `group_by(User.id)` группирует результаты по идентификатору пользователя, позволяя получить количество постов для каждого из них.

### Сортировка результатов

Сортировка позволяет упорядочить результаты запросов по определенным критериям. Это делает вывод данных более понятным и структурированным.

- **Синтаксис**: `query().order_by(Model.field)`
- **Пример**: Чтобы отсортировать пользователей по имени в алфавитном порядке:
  ```python
  sorted_users = session.query(User).order_by(User.name).all()
  ```
- **Пояснение**: Метод `order_by()` принимает поле, по которому нужно отсортировать результаты. В данном случае мы сортируем пользователей по имени. Можно также использовать `desc()` для сортировки по убыванию:
  ```python
  sorted_users_desc = session.query(User).order_by(User.name.desc()).all()
  ```

## 3. Фильтрация данных

### Использование `filter()` и `filter_by()`

Метод `filter()` используется для добавления условий к запросу. Он позволяет использовать выражения для определения критериев фильтрации.

- **Синтаксис**: `session.query(Model).filter(condition)`
- **Пример**: Если вы хотите извлечь пользователей с именем "Alice":
  ```python
  users = session.query(User).filter(User.name == 'Alice').all()
  ```
- **Пояснение**: Здесь `User.name == 'Alice'` является условием фильтрации. Метод `filter()` позволяет использовать более сложные логические выражения.


Метод `filter_by()` более удобен для простых условий, так как он принимает именованные аргументы. Это может сделать код более читабельным.

- **Синтаксис**: `session.query(Model).filter_by(field=value)`
- **Пример**: Чтобы получить всех пользователей с именем "Alice":
  ```python
  users = session.query(User).filter_by(name='Alice').all()
  ```
- **Пояснение**: В этом случае вы просто указываете имя поля и его значение. Это удобный способ фильтрации, особенно для простых случаев.

### Применение различных операторов

SQLAlchemy поддерживает множество операторов для фильтрации, позволяя вам задавать более сложные условия.

#### Равенство и неравенство

- **Равенство**: Используется для нахождения записей с точно заданным значением.
  ```python
  users = session.query(User).filter(User.age == 25).all()
  ```
- **Неравенство**: Позволяет находить записи, которые не равны заданному значению.
  ```python
  users = session.query(User).filter(User.age != 25).all()
  ```

#### LIKE

Оператор `LIKE` используется для поиска подстрок в строковых полях. Это позволяет находить записи, содержащие определенные шаблоны.

- **Синтаксис**: `filter(Model.field.like(pattern))`
- **Пример**: Чтобы найти пользователей, чьи имена начинаются с буквы "A":
  ```python
  users = session.query(User).filter(User.name.like('A%')).all()
  ```
- **Пояснение**: Здесь `%` обозначает любое количество символов. Таким образом, `A%` соответствует любому имени, начинающемуся на "A".


### Комбинирование условий в `filter`

В SQLAlchemy вы можете комбинировать условия в методе `filter()` с помощью операторов `and_` и `or_`, что позволяет создавать более сложные запросы.

#### Использование `and_`

Когда вы хотите, чтобы все условия в запросе выполнялись одновременно, вы можете использовать `and_`. Это полезно, когда необходимо фильтровать результаты по нескольким критериям.

- **Синтаксис**: `filter(and_(condition1, condition2))`
- **Пример**: Предположим, вы хотите извлечь пользователей с именем "Alice" и возрастом старше 30 лет:
  ```python
  from sqlalchemy import and_

  results = session.query(User).filter(
      and_(User.name == 'Alice', User.age > 30)
  ).all()
  ```
- **Пояснение**: Здесь мы используем `and_`, чтобы убедиться, что оба условия выполняются одновременно: имя пользователя должно быть "Alice", а его возраст должен быть больше 30.

#### Использование `or_`

Если вам нужно получить результаты, соответствующие хотя бы одному из условий, используйте `or_`. Это позволяет делать более гибкие запросы.

- **Синтаксис**: `filter(or_(condition1, condition2))`
- **Пример**: Чтобы извлечь пользователей, у которых имя "Alice" или возраст меньше 25 лет:
  ```python
  from sqlalchemy import or_

  results = session.query(User).filter(
      or_(User.name == 'Alice', User.age < 25)
  ).all()
  ```
- **Пояснение**: Здесь `or_` возвращает всех пользователей, которые либо зовут "Alice", либо имеют возраст менее 25 лет.

### Комбинирование `and_` и `or_`

Вы также можете комбинировать условия `and_` и `or_` для создания более сложных фильтров.

- **Пример**: Предположим, вы хотите получить пользователей, которые либо зовут "Alice" и старше 30 лет, либо зовут "Bob":
  ```python
  results = session.query(User).filter(
      or_(
          and_(User.name == 'Alice', User.age > 30),
          User.name == 'Bob'
      )
  ).all()
  ```
- **Пояснение**: В этом случае мы используем вложенные условия. Мы выбираем пользователей, которые либо соответствуют первому условию (имя "Alice" и возраст больше 30), либо второму условию (имя "Bob").

## 4. Пагинация результатов

Пагинация — это процесс разбивки результатов запроса на страницы. Это особенно важно при работе с большими объемами данных, поскольку позволяет пользователям получать данные по частям, не перегружая интерфейс. SQLAlchemy предлагает удобные методы для реализации пагинации с помощью `limit()` и `offset()`.

### Использование `limit()` и `offset()`

#### `limit()`

Метод `limit()` используется для ограничения количества записей, которые будут возвращены в результате запроса. Это позволяет вам управлять объемом данных, отображаемых пользователю.

- **Синтаксис**: `query().limit(n)`
- **Пример**: Если вы хотите извлечь только 10 пользователей:
  ```python
  limited_users = session.query(User).limit(10).all()
  ```
- **Пояснение**: В этом случае `limit(10)` ограничивает выборку до 10 записей. Это полезно, когда вы хотите отображать, например, по 10 пользователей на странице.

#### `offset()`

Метод `offset()` используется для пропуска определенного количества записей перед началом извлечения. Это позволяет вам выбирать данные, начиная с указанной позиции.

- **Синтаксис**: `query().offset(n)`
- **Пример**: Чтобы пропустить первые 10 пользователей и извлечь следующих 10:
  ```python
  paginated_users = session.query(User).offset(10).limit(10).all()
  ```
- **Пояснение**: Здесь `offset(10)` пропускает первые 10 записей и затем применяет `limit(10)`, чтобы вернуть следующих 10 пользователей. Это полезно для реализации навигации между страницами.

## 5. Оптимизация запросов

Оптимизация запросов в SQLAlchemy — это важный аспект работы с базами данных, который помогает улучшить производительность приложений. В этом разделе мы рассмотрим два основных подхода: использование загрузки данных с различными стратегиями и профилирование запросов для выявления узких мест.

### Использование `lazy` и `joined` загрузки

#### `lazy` загрузка

По умолчанию SQLAlchemy использует стратегию `lazy` загрузки, что означает, что связанные данные загружаются только по мере необходимости. Это может помочь избежать избыточной нагрузки на базу данных, но иногда может привести к множественным запросам.

- **Пример**: Если у вас есть модель `User`, связанная с моделью `Post`, при обращении к `user.posts` будут загружены посты только при первом обращении:
  ```python
  user = session.query(User).first()
  posts = user.posts  # Посты загружаются только здесь
  ```
- **Пояснение**: В этом случае, если у вас много пользователей и вы хотите получить их посты, SQLAlchemy выполнит отдельный запрос для каждого пользователя, что может быть неэффективно.

#### `joined` загрузка

`joined` загрузка (или `eager` загрузка) позволяет загружать связанные объекты сразу в одном запросе с использованием SQL JOIN. Это может значительно уменьшить количество запросов к базе данных и повысить производительность.

- **Синтаксис**: `session.query(Model).options(joinedload(Model.related_model))`
- **Пример**: Чтобы загрузить пользователей вместе с их постами:
  ```python
  from sqlalchemy.orm import joinedload

  users_with_posts = session.query(User).options(joinedload(User.posts)).all()
  ```
- **Пояснение**: Здесь `joinedload(User.posts)` указывает SQLAlchemy использовать JOIN, чтобы загрузить посты вместе с пользователями в одном запросе. Это сокращает количество обращений к базе данных, что может значительно ускорить выполнение программы.

### Профилирование запросов

Профилирование запросов помогает вам анализировать производительность SQL-запросов и выявлять узкие места. Это позволяет понимать, какие запросы могут быть оптимизированы.

#### Использование инструмента для профилирования

SQLAlchemy предоставляет возможность включать логирование запросов, чтобы вы могли видеть, какие запросы выполняются и сколько времени на это уходит.

- **Пример**: Включение логирования SQL-запросов:
  ```python
  import logging

  logging.basicConfig()
  logging.getLogger('sqlalchemy.engine').setLevel(logging.INFO)
  ```
- **Пояснение**: После включения логирования все SQL-запросы будут выводиться в консоль, что позволяет вам анализировать их выполнение и выявлять потенциальные проблемы.

#### Анализ производительности

При анализе логов обращайте внимание на следующие аспекты:

1. **Количество запросов**: Если для получения связанных данных выполняется много запросов, подумайте о возможности использования `joined` загрузки.
  
2. **Время выполнения**: Долгие запросы могут сигнализировать о необходимости оптимизации, например, добавления индексов в базе данных.

3. **Общие запросы**: Иногда лучше использовать агрегированные запросы, чтобы уменьшить количество возвращаемых данных.
