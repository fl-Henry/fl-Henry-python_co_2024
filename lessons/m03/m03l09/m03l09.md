# Занятие 9: Определение моделей данных с использованием SQLAlchemy

## 1. Введение в модели данных

### Понятие модели данных в контексте ORM

Модель данных представляет собой абстракцию, которая описывает структуру и поведение данных, используемых в приложении. В контексте ORM (Object-Relational Mapping) модели данных соответствуют таблицам в базе данных и позволяют разработчикам работать с данными на уровне объектов, а не на уровне строк и колонок. 

ORM как концепция создает «мост» между объектно-ориентированным программированием и реляционными базами данных. Это позволяет программистам работать с объектами, которые являются представлением данных, вместо выполнения прямых SQL-запросов. Каждая модель данных отражает отдельную сущность, например, пользователя или продукт, и определяет ее свойства (атрибуты) и поведение.

#### Зачем нужны модели данных

1. **Упрощение работы с данными**: Модели данных абстрагируют взаимодействие с базой данных, позволяя разработчикам работать с объектами вместо того, чтобы писать сложные SQL-запросы. Это делает код более читаемым и поддерживаемым.

2. **Инкапсуляция логики**: Модели позволяют инкапсулировать логику, связанную с определенной сущностью. Например, можно создать методы для валидации данных или бизнес-логики, которые будут работать с атрибутами модели.

3. **Поддержка связей между сущностями**: Модели данных позволяют легко определять и управлять связями между различными сущностями (например, между пользователями и их постами в блоге). Это особенно важно для сложных приложений, где данные взаимосвязаны.

4. **Упрощение миграций**: При изменении структуры базы данных (например, добавлении новых полей или таблиц) изменение модели данных может автоматически привести к обновлению схемы базы данных, что упрощает процесс миграции.

5. **Улучшение тестирования**: Модели данных можно легко тестировать, что помогает убедиться в правильности логики приложения и взаимодействия с базой данных.

6. **Стандартизация**: Использование моделей данных способствует стандартизации подхода к работе с данными в приложении, что особенно полезно в больших командах разработчиков.

В целом, модели данных в ORM играют ключевую роль в разработке современных приложений, упрощая взаимодействие с базой данных и обеспечивая удобные инструменты для работы с данными.



## 2. Декларативный стиль и использование метаданных

### Пояснение декларативного стиля

Декларативный стиль в SQLAlchemy предоставляет удобный способ определения моделей данных и их взаимосвязей, используя Python-классы. Этот подход позволяет разработчикам сосредоточиться на описании структуры данных и логики приложения, вместо того чтобы писать много кода для настройки базы данных.

- **Что такое декларативный стиль?** Это метод, при котором разработчики описывают свои модели и их свойства, используя классы и атрибуты, а SQLAlchemy автоматически управляет созданием таблиц, определением полей и их связями на основе этих описаний. Этот стиль позволяет избежать многоуровневых структур и упрощает чтение и поддержку кода.

- **Преимущества декларативного стиля**:
  - **Читаемость**: Код становится более понятным, так как структуры данных определяются непосредственно через классы и их атрибуты.
  - **Удобство**: Упрощает добавление новых моделей и изменение существующих, так как вся информация о модели находится в одном месте.
  - **Интуитивность**: Работая с Python-классами, разработчики могут использовать привычные паттерны объектно-ориентированного программирования.

### Пример определения метаданных для моделей

Метаданные в SQLAlchemy описывают структуру базы данных и содержат информацию о таблицах, колонках и их свойствах. В декларативном стиле метаданные создаются автоматически при определении классов моделей, наследующих от `Base`.

- **Определение метаданных**: При создании базового класса, используя функцию `declarative_base`, вы создаете класс, который будет использоваться для определения всех моделей в приложении. Этот базовый класс будет содержать всю необходимую информацию о структуре базы данных.

- **Пример кода**:
  ```python
  from sqlalchemy.ext.declarative import declarative_base
  from sqlalchemy import Column, Integer, String

  Base = declarative_base()

  class User(Base):
      __tablename__ = 'users'  # имя таблицы в базе данных

      id = Column(Integer, primary_key=True)  # первичный ключ
      name = Column(String, nullable=False)     # имя пользователя
      age = Column(Integer)                      # возраст пользователя
  ```

В этом примере мы определяем класс `User`, который будет представлять таблицу `users` в базе данных. Атрибуты класса (такие как `id`, `name` и `age`) автоматически становятся колонками в таблице.

- **Обратите внимание на следующие аспекты**:
  - `__tablename__` указывает имя таблицы, которая будет создана в базе данных.
  - Каждый атрибут класса описывает колонку с определенным типом данных и свойствами (например, `nullable`, `primary_key`).
  
- **Создание таблиц**: После определения всех моделей, можно создать таблицы в базе данных, используя метод `Base.metadata.create_all(engine)`, где `engine` — это экземпляр подключения к базе данных.

## 3. Создание классов моделей

### Наследование от `Base`

При создании классов моделей в SQLAlchemy необходимо наследовать свои классы от специального класса `Base`, который предоставляет функциональность для работы с ORM. 

- **Зачем это нужно?** Наследование от `Base` позволяет SQLAlchemy понимать, что этот класс является моделью, которая будет отображаться на таблицу в базе данных. `Base` является частью декларативной системы, которая упрощает процесс создания моделей.
  
- **Пример кода**:
  ```python
  from sqlalchemy.ext.declarative import declarative_base

  Base = declarative_base()

  class User(Base):
      __tablename__ = 'users'
      # атрибуты модели будут определены здесь
  ```

В этом примере мы создаем базовый класс `Base`, а затем определяем модель `User`, которая будет соответствовать таблице `users` в базе данных.

### Определение атрибутов класса

Атрибуты класса представляют собой колонки в таблице базы данных. Каждое свойство класса будет соответствовать полю в таблице, и его тип определяет, как будет храниться данное значение в базе данных.

- **Определение атрибутов**: Атрибуты определяются как переменные внутри класса модели. Каждое свойство должно быть связано с типом данных, который определяет, как данные будут храниться.

- **Пример кода**:
  ```python
  from sqlalchemy import Column, Integer, String

  class User(Base):
      __tablename__ = 'users'
      
      id = Column(Integer, primary_key=True)  # первичный ключ
      name = Column(String, nullable=False)     # имя пользователя
      age = Column(Integer)                      # возраст пользователя
  ```

В этом примере мы определяем три атрибута для модели `User`: `id`, `name` и `age`. `id` является первичным ключом, что означает, что он будет уникальным для каждой записи. Атрибут `name` не может быть пустым (`nullable=False`).

### Примеры типов данных (String, Integer, Float и др.)

SQLAlchemy поддерживает различные типы данных, которые можно использовать для определения атрибутов модели. Вот несколько распространенных типов данных:

1. **String**: Используется для хранения текстовых данных.
   - **Пример**:
     ```python
     name = Column(String(50))  # строка до 50 символов
     ```

2. **Integer**: Используется для хранения целых чисел.
   - **Пример**:
     ```python
     age = Column(Integer)  # целочисленное значение
     ```

3. **Float**: Используется для хранения чисел с плавающей точкой.
   - **Пример**:
     ```python
     price = Column(Float)  # число с плавающей точкой
     ```

4. **Boolean**: Используется для хранения логических значений (True/False).
   - **Пример**:
     ```python
     is_active = Column(Boolean, default=True)  # по умолчанию активен
     ```

5. **DateTime**: Используется для хранения даты и времени.
   - **Пример**:
     ```python
     created_at = Column(DateTime)  # дата и время создания записи
     ```

Каждый тип данных имеет свои особенности и ограничения, поэтому важно выбирать правильный тип в зависимости от конкретной задачи. Использование правильных типов данных не только улучшает производительность, но и обеспечивает целостность данных в базе.

## 4. Задание свойств полей модели

### Ограничения: `nullable`, `unique`, `primary_key`

При создании моделей данных в SQLAlchemy важно правильно задать свойства полей, чтобы обеспечить целостность и правильность данных в базе. Рассмотрим основные ограничения, которые можно применить к атрибутам модели.

1. **`nullable`**: Это свойство определяет, может ли поле содержать `NULL` значения. Если `nullable=False`, это означает, что поле обязательно должно иметь значение, и база данных не позволит вставить запись без него.

   - **Пример**:
     ```python
     name = Column(String, nullable=False)  # имя обязательно
     ```

   В этом примере поле `name` не может быть пустым, и попытка добавить запись без имени приведет к ошибке.

2. **`unique`**: Это свойство гарантирует, что все значения в поле будут уникальными. Если `unique=True`, база данных не позволит вставлять записи с одинаковыми значениями в это поле.

   - **Пример**:
     ```python
     email = Column(String, unique=True)  # уникальный адрес электронной почты
     ```

   Здесь `email` должен быть уникальным для каждой записи. Если попытаться добавить запись с уже существующим адресом, это приведет к ошибке.

3. **`primary_key`**: Это свойство указывает, что данное поле является первичным ключом таблицы. Первичный ключ должен быть уникальным и не может содержать `NULL` значения. Обычно это поле идентифицирует каждую запись в таблице.

   - **Пример**:
     ```python
     id = Column(Integer, primary_key=True)  # уникальный идентификатор
     ```

   В этом случае `id` будет использоваться для уникальной идентификации каждой записи, что делает его основным атрибутом модели.

### Использование `default` и `index`

Помимо ограничений, SQLAlchemy также позволяет задавать дополнительные свойства для полей, такие как `default` и `index`.

1. **`default`**: Это свойство задает значение по умолчанию для поля. Если при вставке записи значение для этого поля не указано, будет использовано заданное значение по умолчанию.

   - **Пример**:
     ```python
     is_active = Column(Boolean, default=True)  # по умолчанию активен
     ```

   Здесь поле `is_active` будет автоматически иметь значение `True`, если пользователь не укажет его при создании записи.

2. **`index`**: Это свойство указывает, что поле должно быть индексировано в базе данных. Индексы помогают ускорить выполнение запросов, особенно при фильтрации и сортировке данных по этому полю.

   - **Пример**:
     ```python
     username = Column(String, index=True)  # индекс для имени пользователя
     ```

   В этом случае база данных создаст индекс для поля `username`, что улучшит производительность запросов, в которых используется это поле.

## 5. Определение связей между моделями

Связи между моделями данных играют ключевую роль в проектировании баз данных, так как они определяют, как различные сущности взаимодействуют друг с другом. В SQLAlchemy можно легко определять и управлять этими связями с помощью функции `relationship`.

### Один к одному

Связь "один к одному" означает, что одной записи в одной таблице соответствует ровно одна запись в другой таблице. Это часто используется, когда одна сущность содержит дополнительную информацию, связанную с другой сущностью.

- **Пример**:
  Рассмотрим модели `User` и `UserProfile`, где каждый пользователь имеет один профиль.

  ```python
  from sqlalchemy import Column, Integer, String, ForeignKey
  from sqlalchemy.orm import relationship

  class User(Base):
      __tablename__ = 'users'
      
      id = Column(Integer, primary_key=True)
      name = Column(String, nullable=False)
      profile = relationship("UserProfile", back_populates="user", uselist=False)

  class UserProfile(Base):
      __tablename__ = 'user_profiles'
      
      id = Column(Integer, primary_key=True)
      user_id = Column(Integer, ForeignKey('users.id'))
      bio = Column(String)

      user = relationship("User", back_populates="profile")
  ```

  В этом примере мы используем `uselist=False` в `relationship`, чтобы указать, что профиль может быть только один для каждого пользователя.

### Один ко многим

Связь "один ко многим" означает, что одной записи в одной таблице может соответствовать множество записей в другой таблице. Это наиболее распространенный тип связи и часто используется, например, для связывания пользователей с их постами.

- **Пример**:
  Рассмотрим модели `User` и `Post`, где один пользователь может иметь много постов.

  ```python
  class User(Base):
      __tablename__ = 'users'
      
      id = Column(Integer, primary_key=True)
      name = Column(String, nullable=False)
      posts = relationship("Post", back_populates="user")

  class Post(Base):
      __tablename__ = 'posts'
      
      id = Column(Integer, primary_key=True)
      user_id = Column(Integer, ForeignKey('users.id'))
      content = Column(String)

      user = relationship("User", back_populates="posts")
  ```

  Здесь `posts` в модели `User` представляет собой список постов, связанных с этим пользователем. Обратная связь обеспечивается с помощью `back_populates`, которая позволяет легко получить доступ к пользователю из поста.

### Многие ко многим

Связь "многие ко многим" позволяет множеству записей в одной таблице быть связанными с множеством записей в другой таблице. Для реализации таких связей в SQLAlchemy необходимо создать промежуточную таблицу.

- **Пример**:
  Рассмотрим модели `Student` и `Course`, где студенты могут записываться на множество курсов, а курсы могут иметь множество студентов.

  ```python
  from sqlalchemy import Table

  enrollment = Table('enrollment', Base.metadata,
      Column('student_id', Integer, ForeignKey('students.id')),
      Column('course_id', Integer, ForeignKey('courses.id'))
  )

  class Student(Base):
      __tablename__ = 'students'
      
      id = Column(Integer, primary_key=True)
      name = Column(String, nullable=False)
      courses = relationship("Course", secondary=enrollment, back_populates="students")

  class Course(Base):
      __tablename__ = 'courses'
      
      id = Column(Integer, primary_key=True)
      title = Column(String, nullable=False)
      students = relationship("Student", secondary=enrollment, back_populates="courses")
  ```

  В этом примере мы создаем промежуточную таблицу `enrollment`, которая связывает студентов и курсы. Использование `secondary` в `relationship` указывает на промежуточную таблицу.

### Примеры реализации связей через `relationship`

Функция `relationship` в SQLAlchemy является мощным инструментом для определения связей между моделями. Она не только связывает модели, но и предоставляет удобный интерфейс для доступа к связанным данным.

- **Преимущества использования `relationship`**:
  - **Упрощение запросов**: Можно легко получить доступ к связанным данным, используя атрибуты, а не явные запросы.
  - **Поддержка обратных связей**: Связи могут быть легко навигируемыми в обе стороны.
  - **Автоматическое управление отношениями**: SQLAlchemy автоматически управляет добавлением и удалением связанных объектов.

## 6. Примеры моделей

Создание моделей данных является важным этапом в проектировании приложения, так как именно они определяют, как данные будут структурированы и взаимодействовать друг с другом.

### Пример 1: Модель пользователя

Для начала создадим модель `User`, которая будет представлять пользователей нашего приложения.

- **Определение модели**:
  ```python
  from sqlalchemy.ext.declarative import declarative_base
  from sqlalchemy import Column, Integer, String

  Base = declarative_base()

  class User(Base):
      __tablename__ = 'users'  # Название таблицы в базе данных

      id = Column(Integer, primary_key=True)  # Уникальный идентификатор
      username = Column(String(50), unique=True, nullable=False)  # Имя пользователя
      email = Column(String(100), unique=True, nullable=False)  # Адрес электронной почты
  ```

- **Объяснение кода**:
  - `__tablename__`: Указывает название таблицы в базе данных, которая будет создана для модели.
  - `id`: Первичный ключ, который будет уникальным для каждой записи.
  - `username` и `email`: Строковые поля, которые не могут быть пустыми и должны быть уникальными, что гарантирует, что каждый пользователь имеет уникальные имя и адрес электронной почты.

### Пример 2: Модель статьи
Теперь создадим более сложные модели для типичного приложения, такого как блог, где у нас будут пользователи и статьи.

Модель `Post` будет представлять статьи, написанные пользователями.

- **Определение модели**:
  ```python
  from sqlalchemy import ForeignKey
  from sqlalchemy.orm import relationship

  class Post(Base):
      __tablename__ = 'posts'  # Название таблицы для статей

      id = Column(Integer, primary_key=True)  # Уникальный идентификатор статьи
      title = Column(String(200), nullable=False)  # Заголовок статьи
      content = Column(String, nullable=False)  # Содержимое статьи
      user_id = Column(Integer, ForeignKey('users.id'))  # Ссылка на автора статьи

      user = relationship("User", back_populates="posts")  # Связь с пользователем

  class User(Base):
      __tablename__ = 'users'

      id = Column(Integer, primary_key=True)
      username = Column(String(50), unique=True, nullable=False)
      email = Column(String(100), unique=True, nullable=False)

      posts = relationship("Post", back_populates="user")  # Связь с статьями
  ```

- **Объяснение кода**:
  - `title` и `content`: Поля для заголовка и содержимого статьи, которые обязательны для заполнения.
  - `user_id`: Ссылается на `id` пользователя, который создал статью. Использование `ForeignKey` создает связь с таблицей пользователей.
  - `user`: Используется для определения связи с моделью `User`, что позволяет легко получить автора статьи.
