<h2 id="m1l10">Занятие 10: Введение в функциональное программирование и ООП</h2>

### Функциональное программирование

#### 1. Введение в функциональное программирование

**Определение функционального программирования:**
Функциональное программирование (ФП) — это парадигма программирования, где вычисления представляют собой применение функций к аргументам. Основная идея заключается в использовании функций как первичных средств для вычислений, а также в избегании изменений состояния и побочных эффектов.

**Основные принципы функционального программирования:**

- **Чистые функции:** 
  - Это функции, которые для одних и тех же входных данных всегда возвращают один и тот же результат и не имеют побочных эффектов (не изменяют состояние вне своей области видимости).
  - Пример чистой функции:
    ```python
    def add(a, b):
        return a + b
    ```

- **Неизменяемость данных:**
  - В ФП принято использовать неизменяемые структуры данных. Это означает, что после создания объекта его состояние нельзя изменить.
  - Примеры неизменяемых структур данных в Python: строки, кортежи.
  - Пример:
    ```python
    s = "hello"
    s = s.upper()  # создается новый объект, переменная s ссылается на него
    ```

- **Функции как объекты первого класса:**
  - В ФП функции могут быть переданы в качестве аргументов другим функциям, возвращены из других функций и присвоены переменным.
  - Пример:
    ```python
    def greet(name):
        return f"Hello, {name}!"

    def call_function(func, value):
        return func(value)

    print(call_function(greet, "Alice"))  # Вывод: Hello, Alice!
    ```

#### 2. Основные функции и методы в Python

**Определение и вызов функций:**
- Функции в Python определяются с помощью ключевого слова `def`, и их можно вызывать по имени с передачей аргументов.
- Пример определения и вызова функции:
  ```python
  def square(x):
      return x * x

  result = square(5)
  print(result)  # Вывод: 25
  ```

**Лямбда-функции (анонимные функции):**
- Лямбда-функции — это функции без имени, которые можно создавать на лету. Они обычно используются для коротких функций, которые могут быть определены в одном выражении.
- Синтаксис лямбда-функции:
  ```python
  lambda arguments: expression
  ```
- Пример:
  ```python
  add = lambda x, y: x + y
  print(add(3, 4))  # Вывод: 7
  ```

**Функции высшего порядка:**
- Функции высшего порядка — это функции, которые принимают другие функции в качестве аргументов или возвращают функции в качестве результата.

  - **`map()`**: применяет функцию к каждому элементу итерируемого объекта.
    ```python
    numbers = [1, 2, 3, 4]
    squares = map(lambda x: x ** 2, numbers)
    print(list(squares))  # Вывод: [1, 4, 9, 16]
    ```

  - **`filter()`**: фильтрует элементы итерируемого объекта по функции, которая возвращает `True` или `False`.
    ```python
    numbers = [1, 2, 3, 4]
    even_numbers = filter(lambda x: x % 2 == 0, numbers)
    print(list(even_numbers))  # Вывод: [2, 4]
    ```

  - **`reduce()`**: сводит элементы итерируемого объекта к одному значению с помощью функции. Требует импорта из модуля `functools`.
    ```python
    from functools import reduce

    numbers = [1, 2, 3, 4]
    product = reduce(lambda x, y: x * y, numbers)
    print(product)  # Вывод: 24
    ```

#### 3. Композиция функций и каррирование

**Определение композиции функций:**
- Композиция функций — это процесс объединения нескольких функций в одну, где результат одной функции становится входом для следующей.
- Пример композиции:
  ```python
  def double(x):
      return x * 2

  def square(x):
      return x * x

  def double_then_square(x):
      return square(double(x))

  print(double_then_square(3))  # Вывод: 36
  ```

**Пример каррирования с использованием `functools.partial`:**
- Каррирование — это преобразование функции с несколькими аргументами в последовательность функций с одним аргументом.
- Модуль `functools` предоставляет `partial`, чтобы частично фиксировать аргументы функции.
- Пример:
  ```python
  from functools import partial

  def power(base, exponent):
      return base ** exponent

  square = partial(power, exponent=2)
  print(square(5))  # Вывод: 25
  ```


### Объектно-Ориентированное Программирование (ООП)


#### 2. Классы и объекты в Python

**Определение классов и объектов:**
- Класс — это шаблон для создания объектов. Он определяет набор атрибутов и методов, которые будут у объектов этого класса.
- Объект — это экземпляр класса, который содержит конкретные данные и может использовать методы, определенные в классе.

**Определение класса:**
```python
class Car:
    def __init__(self, make, model):
        self.make = make
        self.model = model

    def display_info(self):
        return f"{self.make} {self.model}"
```

**Создание объекта:**
```python
my_car = Car("Toyota", "Corolla")
print(my_car.display_info())  # Вывод: Toyota Corolla
```

**Конструкторы и методы:**
- Конструктор `__init__` используется для инициализации нового объекта.
- Методы определяются внутри класса и могут использоваться для выполнения операций с данными объекта.

**Пример конструктора и метода:**
```python
class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height
```

**Атрибуты и свойства:**
- Атрибуты — это переменные, которые хранят данные о состоянии объекта.
- Свойства (`property`) — это специальный вид атрибутов, который позволяет контролировать доступ к данным через методы.

**Пример свойства:**
```python
class Person:
    def __init__(self, name, age):
        self._name = name
        self._age = age

    @property
    def age(self):
        return self._age

    @age.setter
    def age(self, value):
        if value >= 0:
            self._age = value
```

#### 2. Введение в ООП и основные принципы

**Определение ООП:**
Объектно-Ориентированное Программирование (ООП) — это парадигма программирования, которая основывается на концепции объектов. Объекты представляют собой экземпляры классов и инкапсулируют данные и методы, которые работают с этими данными. ООП позволяет моделировать реальные сущности и их взаимодействия, что упрощает разработку, поддержку и расширение программного обеспечения.

**Основные принципы ООП:**

- **Инкапсуляция:**
  - Инкапсуляция — это сокрытие внутренней реализации объекта и предоставление публичного интерфейса для взаимодействия с ним. Это позволяет скрыть детали реализации и защитить данные от неконтролируемого доступа.
  - Пример:
    ```python
    class BankAccount:
        def __init__(self, balance):
            self.__balance = balance  # Приватный атрибут

        def deposit(self, amount):
            if amount > 0:
                self.__balance += amount

        def get_balance(self):
            return self.__balance
    ```

- **Наследование:**
  - Наследование позволяет создавать новый класс на основе существующего, унаследовав его свойства и методы. Это способствует повторному использованию кода и расширению функциональности.
  - Пример:
    ```python
    class Animal:
        
        x = 0
        y = x

        def walk_x(self):
          return self.x + 1

        def speak(self):
            return "Some sound"

    class Dog(Animal):
        def speak(self):
            return "Woof"
    ```

- **Полиморфизм:**
  - Полиморфизм позволяет объектам разных классов реагировать на одни и те же сообщения (методы) разным образом. Это достигается путем переопределения методов в производных классах.
  - Пример:
    ```python
    def make_animal_speak(animal):
        print(animal.speak())

    dog = Dog()
    cat = Animal()
    make_animal_speak(dog)  # Вывод: Woof
    make_animal_speak(cat)  # Вывод: Some sound
    ```

- **Абстракция:**
  - Абстракция подразумевает выделение только тех деталей объекта, которые необходимы пользователю, скрывая сложность реализации. Это позволяет сосредоточиться на взаимодействии с объектом, не вдаваясь в детали его реализации.
  - Пример:
    ```python
    from abc import ABC, abstractmethod

    class Shape(ABC):
        @abstractmethod
        def area(self):
            pass

    class Circle(Shape):
        def __init__(self, radius):
            self.radius = radius

        def area(self):
            return 3.14 * (self.radius ** 2)
    ```

#### 3. Инкапсуляция и специальные методы

**Принципы инкапсуляции:**
- Инкапсуляция предполагает скрытие данных объекта и предоставление методов для управления доступом к этим данным.

**Пример инкапсуляции:**
```python
class Person:
    def __init__(self, name):
        self.__name = name  # Приватный атрибут

    def get_name(self):
        return self.__name

    def set_name(self, name):
        self.__name = name
```

**Специальные методы:**
- Специальные методы (или методы с магическими методами) — это методы, которые имеют двойные подчеркивания в начале и конце имени. Они предоставляют доступ к специальным операциям и встроенным функциям.

**Примеры специальных методов:**

- `__init__`: Конструктор класса.
  ```python
  class Person:
      def __init__(self, name):
          self.name = name
  ```

- `__str__`: Возвращает строковое представление объекта, используемое функцией `print`.
  ```python
  class Person:
      def __str__(self):
          return f"Person(name={self.name})"
  ```

- `__repr__`: Возвращает строковое представление объекта, подходящее для отладки и создания нового объекта.
  ```python
  class Person:
      def __repr__(self):
          return f"Person(name={self.name!r})"
  ```

- `__getitem__` и `__setitem__`: Определяют поведение при доступе к элементам по индексу.
  ```python
  class MyList:
      def __init__(self, data):
          self._data = data

      def __getitem__(self, index):
          return self._data[index]

      def __setitem__(self, index, value):
          self._data[index] = value
  ```



### Задача 1: Создание класса и использование объектов

**Описание задачи:**

Создайте класс `Book`, который будет представлять книгу. Этот класс должен включать следующие атрибуты: название (`title`), автор (`author`) и год публикации (`publication_year`). Реализуйте конструктор класса для инициализации этих атрибутов. Затем создайте несколько объектов этого класса и продемонстрируйте использование этих объектов.

**Требования:**

1. **Класс `Book`:**
   - Атрибуты:
     - `title` (строка)
     - `author` (строка)
     - `publication_year` (целое число)
   - Методы:
     - `__init__()` — конструктор класса для инициализации атрибутов.

**Пример кода:**

```python
# Создание класса Book (написать)
...

# Создание объектов класса Book
book1 = Book("1984", "George Orwell", 1949)
book2 = Book("To Kill a Mockingbird", "Harper Lee", 1960)

# Использование объектов. Убедиться что объекты класса действительно
# разные (содержат разные состояния)
print(f"Book 1: Title: {book1.title}, Author: {book1.author}, Year: {book1.publication_year}")
print(f"Book 2: Title: {book2.title}, Author: {book2.author}, Year: {book2.publication_year}")
```

### Задача 2: Методы и специальные методы

**Описание задачи:**
Создайте класс `Rectangle`, который будет представлять прямоугольник. Реализуйте методы для вычисления площади (`area`) и периметра (`perimeter`) прямоугольника. Также реализуйте специальнй метод `__str__` для возвращения строкового представления прямоугольника.

**Требования:**

1. **Класс `Rectangle`:**
   - Атрибуты:
     - `width` (ширина)
     - `height` (высота)
   - Методы:
     - `area()` — возвращает площадь прямоугольника.
     - `perimeter()` — возвращает периметр прямоугольника.
     - `__str__()` — возвращает строковое представление прямоугольника (ворзвращает строку, которая описывает характеристики объекта).

**Пример кода:**

```python
# Создание класса Rectangle (написать)
...

# Создание объектов класса Rectangle
rect1 = Rectangle(4, 5)
rect2 = Rectangle(6, 5)
rect3 = Rectangle(6, 7)

for index, rect in zip(range(1, 4), [rect1, rect2, rect3]):
  # Использование методов и специальных методов
  print(rect)  # Строковое представление (проверка работы метода __str__)
  print(f"Area of rect{index}: {rect.area()}")
  print(f"Perimeter of rect{index}: {rect.perimeter()}")

```
